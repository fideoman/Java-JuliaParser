(unit (block (statement (typeDeclaration typealias AbstractVector (typeParameters { (typeParameter (exp T)) }) (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 1))) })))) (statement (typeDeclaration typealias AbstractMatrix (typeParameters { (typeParameter (exp T)) }) (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 2))) })))) (statement (typeDeclaration typealias AbstractVecOrMat (typeParameters { (typeParameter (exp T)) }) (typeExpression Union { (typeExpression AbstractVector (typeParameters { (typeParameter (exp T)) })) , (typeExpression AbstractMatrix (typeParameters { (typeParameter (exp T)) })) }))) (statement (typeDeclaration typealias RangeIndex (typeExpression Union { (typeExpression Int) , (typeExpression Range (typeParameters { (typeParameter (exp Int)) })) , (typeExpression UnitRange (typeParameters { (typeParameter (exp Int)) })) , (typeExpression Colon) }))) (statement (functionDeclaration (name vect) (parameters ( )) = (exp (name Array) ( (exp Any) , (exp 0) )))) (statement (functionDeclaration (name vect) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp i) ]) for (exp i) = (exp (exp 1) : (exp (name length) ( (exp X) ))) ])) (statement (exp const _oldstyle_array_vcat_ = (exp true))) (statement (exp if (exp _oldstyle_array_vcat_) (block (statement (functionDeclaration function (name oldstyle_vcat_warning) (parameters ( (parameter n :: (typeExpression Int)) )) (block (statement (exp if (exp (exp n) == (exp 1)) (block (statement (exp (exp before) = (exp "[a]"))) (statement (exp (exp after) = (exp "collect(a)")))) elseif (exp (exp n) == (exp 2)) (block (statement (exp (exp before) = (exp "[a,b]"))) (statement (exp (exp after) = (exp "[a;b]")))) else (block (statement (exp (exp before) = (exp "[a,b,...]"))) (statement (exp (exp after) = (exp "[a;b;...]")))) end)) (statement (exp (name depwarn) ( (exp "$before concatenation is deprecated; use $after instead") , (exp : (exp vect)) )))) end)) (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) (block (statement (exp (name oldstyle_vcat_warning) ( (exp (name length) ( (exp A) )) ))) (statement (exp (name vcat) ( (exp (exp A) ...) )))) end)) (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter X) ...) )) (block (statement (exp for (exp a) in (exp X) (block (statement (exp if (exp (exp (name typeof) ( (exp a) )) <: (exp AbstractArray)) (block (statement (exp (name oldstyle_vcat_warning) ( (exp (name length) ( (exp X) )) ))) (statement (exp break))) end))) end)) (statement (exp (name vcat) ( (exp (exp X) ...) )))) end))) else (block (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter X) ...) )) (block (statement (exp (exp T) = (exp (name promote_typeof) ( (exp (exp X) ...) )))) (statement (exp (name copy!) ( (exp (name Array) ( (exp T) , (exp (name length) ( (exp X) )) )) , (exp X) )))) end))) end)) (statement (functionDeclaration (name size) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter t :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp n))) }))) , (parameter d) )) = (exp (exp (exp d) <= (exp n)) ? (exp (exp (name size) ( (exp t) )) [ (exp d) ]) : (exp 1)))) (statement (functionDeclaration (name size) (parameters ( (parameter x) , (parameter d1 :: (typeExpression Integer)) , (parameter d2 :: (typeExpression Integer)) , (parameter (parameter dx :: (typeExpression Integer)) ...) )) = (exp (name tuple) ( (exp (name size) ( (exp x) , (exp d1) )) , (exp (exp (name size) ( (exp (exp x) , (exp d2)) , (exp (exp dx) ...) )) ...) )))) (statement (functionDeclaration (name eltype) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) })))) }))) )) = (exp T))) (statement (functionDeclaration (name eltype) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp n))) })))) }))) )) = (exp T))) (statement (functionDeclaration (name elsize) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name sizeof) ( (exp T) )))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp n))) }))) )) = (exp n))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp n))) })))) }))) )) = (exp n))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter T <: (typeExpression AbstractArray)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name ndims) ( (exp (name super) ( (exp T) )) )))) (statement (functionDeclaration (name length) (parameters ( (parameter t :: (typeExpression AbstractArray)) )) = (exp (exp (name prod) ( (exp (name size) ( (exp t) )) )) :: (typeExpression Int)))) (statement (functionDeclaration (name endof) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (name length) ( (exp a) )))) (statement (functionDeclaration (name first) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (exp a) [ (exp (name first) ( (exp (name eachindex) ( (exp a) )) )) ]))) (statement (functionDeclaration function (name first) (parameters ( (parameter itr) )) (block (statement (exp (exp state) = (exp (name start) ( (exp itr) )))) (statement (exp (exp (name done) ( (exp itr) , (exp state) )) && (exp (name throw) ( (exp (name ArgumentError) ( (exp "collection must be non-empty") )) )))) (statement (exp (exp (name next) ( (exp itr) , (exp state) )) [ (exp 1) ]))) end)) (statement (functionDeclaration (name last) (parameters ( (parameter a) )) = (exp (exp a) [ (exp end) ]))) (statement (functionDeclaration function (name stride) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter i :: (typeExpression Integer)) )) (block (statement (exp if (exp (exp i) > (exp (name ndims) ( (exp a) ))) (block (statement (exp return (exp (name length) ( (exp a) ))))) end)) (statement (exp (exp s) = (exp 1))) (statement (exp for (exp n) = (exp (exp 1) : (exp ( (exp (exp i) - (exp 1)) ))) (block (statement (exp (exp s) *= (exp (name size) ( (exp a) , (exp n) ))))) end)) (statement (exp return (exp s)))) end)) (statement (functionDeclaration (name strides) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (exp (name ntuple) ( (exp (exp i) -> (exp (name stride) ( (exp a) , (exp i) ))) , (exp (name ndims) ( (exp a) )) )) :: (typeExpression Dims)))) (statement (functionDeclaration function (name isassigned) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter (parameter i :: (typeExpression Int)) ...) )) (block (statement (exp try (block (statement (exp (exp a) [ (exp (exp i) ...) ])) (statement (exp true))) catch (block (statement (exp false))) end))) end)) (statement (functionDeclaration function (name trailingsize) (parameters ( (parameter A) , (parameter n) )) (block (statement (exp (exp s) = (exp 1))) (statement (exp for (exp i) = (exp (exp n) : (exp (name ndims) ( (exp A) ))) (block (statement (exp (exp s) *= (exp (name size) ( (exp A) , (exp i) ))))) end)) (statement (exp return (exp s)))) end)) (statement (typeDeclaration abstract LinearIndexing)) (statement (typeDeclaration immutable LinearFast <: LinearIndexing end)) (statement (typeDeclaration immutable LinearSlow <: LinearIndexing end)) (statement (functionDeclaration (name linearindexing) (parameters ( (parameter A :: (typeExpression AbstractArray)) )) = (exp (name linearindexing) ( (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration (name linearindexing) (typeParameters { (typeParameter T <: (typeExpression AbstractArray)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name LinearSlow) ( )))) (statement (functionDeclaration (name linearindexing) (typeParameters { (typeParameter T <: (typeExpression Array)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name LinearFast) ( )))) (statement (functionDeclaration (name linearindexing) (typeParameters { (typeParameter T <: (typeExpression Range)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name LinearFast) ( )))) (statement (functionDeclaration (name linearindexing) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) = (exp (name linearindexing) ( (exp (name linearindexing) ( (exp A) )) , (exp (name linearindexing) ( (exp B) )) )))) (statement (functionDeclaration (name linearindexing) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter B :: (typeExpression AbstractArray)) ...) )) = (exp (name linearindexing) ( (exp (name linearindexing) ( (exp A) )) , (exp (name linearindexing) ( (exp (exp B) ...) )) )))) (statement (functionDeclaration (name linearindexing) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter :: (typeExpression LinearFast)) )) = (exp (name LinearFast) ( )))) (statement (functionDeclaration (name linearindexing) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter :: (typeExpression LinearIndexing)) )) = (exp (name LinearSlow) ( )))) (statement (macroDeclaration macro _inline_meta (parameters ( )) (block (statement (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )))) end)) (statement (macroDeclaration macro _noinline_meta (parameters ( )) (block (statement (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp noinline)) )))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name trailingsize) (typeParameters { (typeParameter (exp (exp (exp T) , (exp N)) , (exp n))) }) (parameters ( (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) }))) , (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression Val (typeParameters { (typeParameter (exp n)) })))) }))) )) (block (statement (exp (exp (exp n) > (exp N)) && (exp return (exp 1)))) (statement (exp (exp ex) = (exp : (exp ( (exp (name size) ( (exp A) , (exp $ (exp n)) )) ))))) (statement (exp for (exp m) = (exp (exp n) + (exp (exp 1) : (exp N))) (block (statement (exp (exp ex) = (exp : (exp ( (exp (exp $ (exp ex)) * (exp (name size) ( (exp A) , (exp $ (exp m)) ))) )))))) end)) (statement (exp (name Expr) ( (exp (exp : (exp block)) , (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) ))) , (exp ex) )))) end)) (statement (functionDeclaration (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter i) )) = (exp (name throw) ( (exp (name ArgumentError) ( (exp "unable to check bounds for indices of type $(typeof(i))") )) )))) (statement (functionDeclaration (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter i :: (typeExpression Real)) )) = (exp (exp (exp 1) <= (exp i)) <= (exp sz)))) (statement (functionDeclaration (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter :: (typeExpression Colon)) )) = (exp true))) (statement (functionDeclaration function (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter r :: (typeExpression Range)) )) (block (statement (exp @ (name _inline_meta) (exp (exp (name isempty) ( (exp r) )) || (exp ( (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp sz)) , (exp (name minimum) ( (exp r) )) )) && (exp (name checkbounds) ( (exp (exp Bool) , (exp sz)) , (exp (name maximum) ( (exp r) )) ))) )))))) end)) (statement (functionDeclaration (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter I :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp Bool)) }))) )) = (exp (exp (name length) ( (exp I) )) == (exp sz)))) (statement (functionDeclaration function (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Integer)) , (parameter I :: (typeExpression AbstractArray)) )) (block (statement (exp @ (name _inline_meta) (exp (exp b) = (exp true)) (exp for (exp i) in (exp I) (block (statement (exp (exp b) &= (exp (name checkbounds) ( (exp (exp Bool) , (exp sz)) , (exp i) ))))) end) (exp b)))) end)) (statement (functionDeclaration (name throw_boundserror) (parameters ( (parameter A) , (parameter I) )) = (exp ( (exp (exp @ (name _noinline_meta)) ; (exp (name throw) ( (exp (name BoundsError) ( (exp A) , (exp I) )) ))) )))) (statement (functionDeclaration (name checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name _internal_checkbounds) ( (exp A) , (exp (exp I) ...) ))) )))) (statement (functionDeclaration (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp Bool)) }))) )) = (exp (exp (exp (name size) ( (exp A) )) == (exp (name size) ( (exp I) ))) || (exp (name throw_boundserror) ( (exp A) , (exp I) ))))) (statement (functionDeclaration (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression AbstractVector (typeParameters { (typeParameter (exp Bool)) }))) )) = (exp (exp (exp (name length) ( (exp A) )) == (exp (name length) ( (exp I) ))) || (exp (name throw_boundserror) ( (exp A) , (exp I) ))))) (statement (functionDeclaration (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name length) ( (exp A) ))) , (exp I) )) || (exp (name throw_boundserror) ( (exp A) , (exp I) )))) )))) (statement (functionDeclaration function (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractMatrix)) , (parameter I) , (parameter J) )) (block (statement (exp (exp @ (name _inline_meta) ( (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name size) ( (exp A) , (exp 1) ))) , (exp I) )) && (exp (name checkbounds) ( (exp (exp Bool) , (exp (name size) ( (exp A) , (exp 2) ))) , (exp J) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp ( (exp I) , (exp J) )) ))))) end)) (statement (functionDeclaration function (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I) , (parameter J) )) (block (statement (exp (exp @ (name _inline_meta) ( (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name size) ( (exp A) , (exp 1) ))) , (exp I) )) && (exp (name checkbounds) ( (exp (exp Bool) , (exp (name trailingsize) ( (exp A) , (exp (typeExpression Val (typeParameters { (typeParameter (exp 2)) }))) ))) , (exp J) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp ( (exp I) , (exp J) )) ))))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _internal_checkbounds) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) (block (statement (exp (exp meta) = (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )))) (statement (exp (exp N) = (exp (name length) ( (exp I) )))) (statement (exp (exp Isplat) = (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp N)) ]))) (statement (exp (exp error) = (exp : (exp ( (exp (name throw_boundserror) ( (exp A) , (exp (name tuple) ( (exp $ (exp ( (exp (exp Isplat) ...) ))) )) )) ))))) (statement (exp (exp args) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name size) ( (exp A) , (exp $ (exp dim)) ))) , (exp (exp I) [ (exp $ (exp dim)) ]) )) || (exp $ (exp error))) ))) for (exp dim) in (exp (exp 1) : (exp (exp N) - (exp 1))) ])) (statement (exp (name push!) ( (exp args) , (exp : (exp ( (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name trailingsize) ( (exp A) , (exp (typeExpression Val (typeParameters { (typeParameter (exp $ (exp N))) }))) ))) , (exp (exp I) [ (exp $ (exp N)) ]) )) || (exp $ (exp error))) ))) ))) (statement (exp (name Expr) ( (exp (exp : (exp block)) , (exp meta)) , (exp (exp args) ...) )))) end)) (statement (functionDeclaration function (name checkbounds) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Bool)) }))) , (parameter sz :: (typeExpression Dims)) , (parameter (parameter I) ...) )) (block (statement (exp (exp n) = (exp (name length) ( (exp I) )))) (statement (exp for (exp dim) = (exp (exp 1) : (exp ( (exp (exp n) - (exp 1)) ))) (block (statement (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (exp sz) [ (exp dim) ])) , (exp (exp I) [ (exp dim) ]) )) || (exp return (exp false))))) end)) (statement (exp (exp (exp s) = (exp sz)) [ (exp n) ])) (statement (exp for (exp i) = (exp (exp n) + (exp (exp 1) : (exp (name length) ( (exp sz) )))) (block (statement (exp (exp (exp s) *= (exp sz)) [ (exp i) ]))) end)) (statement (exp (name checkbounds) ( (exp (exp Bool) , (exp s)) , (exp (exp I) [ (exp n) ]) )))) end)) (statement (functionDeclaration (name similar) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter a :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name similar) ( (exp (exp a) , (exp T)) , (exp (name size) ( (exp a) )) )))) (statement (functionDeclaration (name similar) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter T) )) = (exp (name similar) ( (exp (exp a) , (exp T)) , (exp (name size) ( (exp a) )) )))) (statement (functionDeclaration (name similar) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter a :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter dims :: (typeExpression Dims)) )) = (exp (name similar) ( (exp (exp a) , (exp T)) , (exp dims) )))) (statement (functionDeclaration (name similar) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter a :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter (parameter dims :: (typeExpression Int)) ...) )) = (exp (name similar) ( (exp (exp a) , (exp T)) , (exp dims) )))) (statement (functionDeclaration (name similar) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter T) , (parameter (parameter dims :: (typeExpression Int)) ...) )) = (exp (name similar) ( (exp (exp a) , (exp T)) , (exp dims) )))) (statement (functionDeclaration (name similar) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter T) , (parameter dims :: (typeExpression Dims)) )) = (exp (name Array) ( (exp T) , (exp dims) )))) (statement (functionDeclaration function (name reshape) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter dims :: (typeExpression Dims)) )) (block (statement (exp if (exp (exp (name prod) ( (exp dims) )) != (exp (name length) ( (exp a) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "dimensions must be consistent with array size (expected $(length(a)), got $(prod(dims)))") )) )))) end)) (statement (exp (name copy!) ( (exp (name similar) ( (exp a) , (exp dims) )) , (exp a) )))) end)) (statement (functionDeclaration (name reshape) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter (parameter dims :: (typeExpression Int)) ...) )) = (exp (name reshape) ( (exp a) , (exp dims) )))) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter src) )) (block (statement (exp (exp i) = (exp 1))) (statement (exp for (exp x) in (exp src) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp x))) (statement (exp (exp i) += (exp 1)))) end)) (statement (exp return (exp dest)))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src) )) (block (statement (exp (exp (exp doffs) < (exp 1)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp doffs) )) )))) (statement (exp (exp st) = (exp (name start) ( (exp src) )))) (statement (exp (exp (exp i) , (exp (exp dmax) = (exp doffs))) , (exp (name length) ( (exp dest) )))) (statement (exp @ (name inbounds) (exp while (exp ! (exp (name done) ( (exp src) , (exp st) ))) (block (statement (exp (exp (exp i) > (exp dmax)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp i) )) )))) (statement (exp (exp val) , (exp (exp st) = (exp (name next) ( (exp src) , (exp st) ))))) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp val))) (statement (exp (exp i) += (exp 1)))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src) , (parameter soffs :: (typeExpression Integer)) )) (block (statement (exp if (exp (exp ( (exp (exp doffs) < (exp 1)) )) | (exp ( (exp (exp soffs) < (exp 1)) ))) (block (statement (exp (exp (exp doffs) < (exp 1)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp doffs) )) )))) (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp "source start offset (") , (exp soffs)) , (exp ") is < 1") )) )) )))) end)) (statement (exp (exp st) = (exp (name start) ( (exp src) )))) (statement (exp for (exp j) = (exp (exp 1) : (exp ( (exp (exp soffs) - (exp 1)) ))) (block (statement (exp if (exp (name done) ( (exp src) , (exp st) )) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source has fewer elements than required, ") , (exp "expected at least ")) , (exp soffs)) , (exp ", got ")) , (exp (exp j) - (exp 1)) )) )) )))) end)) (statement (exp (exp _) , (exp (exp st) = (exp (name next) ( (exp src) , (exp st) )))))) end)) (statement (exp (exp dn) = (exp (name done) ( (exp src) , (exp st) )))) (statement (exp if (exp dn) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source has fewer elements than required, ") , (exp "expected at least ")) , (exp soffs)) , (exp ", got ")) , (exp (exp soffs) - (exp 1)) )) )) )))) end)) (statement (exp (exp (exp i) , (exp (exp dmax) = (exp doffs))) , (exp (name length) ( (exp dest) )))) (statement (exp @ (name inbounds) (exp while (exp ! (exp dn)) (block (statement (exp (exp (exp i) > (exp dmax)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp i) )) )))) (statement (exp (exp val) , (exp (exp st) = (exp (name next) ( (exp src) , (exp st) ))))) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp val))) (statement (exp (exp i) += (exp 1))) (statement (exp (exp dn) = (exp (name done) ( (exp src) , (exp st) ))))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src) , (parameter soffs :: (typeExpression Integer)) , (parameter n :: (typeExpression Integer)) )) (block (statement (exp (exp (exp n) < (exp 0)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp n) )) )))) (statement (exp (exp (exp n) == (exp 0)) && (exp return (exp dest)))) (statement (exp (exp dmax) = (exp (exp doffs) + (exp (exp n) - (exp 1))))) (statement (exp if (exp (exp (exp ( (exp (exp dmax) > (exp (name length) ( (exp dest) ))) )) | (exp ( (exp (exp doffs) < (exp 1)) ))) | (exp ( (exp (exp soffs) < (exp 1)) ))) (block (statement (exp (exp (exp doffs) < (exp 1)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp doffs) )) )))) (statement (exp (exp (exp soffs) < (exp 1)) && (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp "source start offset (") , (exp soffs)) , (exp ") is < 1") )) )) )))) (statement (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp dmax) )) )))) end)) (statement (exp (exp st) = (exp (name start) ( (exp src) )))) (statement (exp for (exp j) = (exp (exp 1) : (exp ( (exp (exp soffs) - (exp 1)) ))) (block (statement (exp if (exp (name done) ( (exp src) , (exp st) )) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source has fewer elements than required, ") , (exp "expected at least ")) , (exp soffs)) , (exp ", got ")) , (exp (exp j) - (exp 1)) )) )) )))) end)) (statement (exp (exp _) , (exp (exp st) = (exp (name next) ( (exp src) , (exp st) )))))) end)) (statement (exp (exp i) = (exp doffs))) (statement (exp @ (name inbounds) (exp while (exp (exp (exp i) <= (exp dmax)) && (exp ! (exp (name done) ( (exp src) , (exp st) )))) (block (statement (exp (exp val) , (exp (exp st) = (exp (name next) ( (exp src) , (exp st) ))))) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp val))) (statement (exp (exp i) += (exp 1)))) end) (exp (exp (exp i) <= (exp dmax)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp i) )) ))) (exp return (exp dest))))) end)) (statement (functionDeclaration (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter src :: (typeExpression AbstractArray)) )) = (exp (name copy!) ( (exp (exp (exp (name linearindexing) ( (exp dest) )) , (exp dest)) , (exp (name linearindexing) ( (exp src) ))) , (exp src) )))) (statement (functionDeclaration function (name copy!) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter :: (typeExpression LinearIndexing)) , (parameter src :: (typeExpression AbstractArray)) )) (block (statement (exp (exp n) = (exp (name length) ( (exp src) )))) (statement (exp (exp (exp n) > (exp (name length) ( (exp dest) ))) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp n) )) )))) (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp 1) : (exp n)) (block (statement (exp (exp (exp (exp dest) [ (exp i) ]) = (exp src)) [ (exp i) ]))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter :: (typeExpression LinearSlow)) , (parameter src :: (typeExpression AbstractArray)) )) (block (statement (exp (exp n) = (exp (name length) ( (exp src) )))) (statement (exp (exp (exp n) > (exp (name length) ( (exp dest) ))) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp n) )) )))) (statement (exp (exp i) = (exp 0))) (statement (exp @ (name inbounds) (exp for (exp a) in (exp src) (block (statement (exp (exp (exp dest) [ (exp (exp i) += (exp 1)) ]) = (exp a)))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src :: (typeExpression AbstractArray)) )) (block (statement (exp (name copy!) ( (exp (exp (exp (exp dest) , (exp doffs)) , (exp src)) , (exp 1)) , (exp (name length) ( (exp src) )) )))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src :: (typeExpression AbstractArray)) , (parameter soffs :: (typeExpression Integer)) )) (block (statement (exp (exp (exp soffs) > (exp (name length) ( (exp src) ))) && (exp (name throw) ( (exp (name BoundsError) ( (exp src) , (exp soffs) )) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp dest) , (exp doffs)) , (exp src)) , (exp soffs)) , (exp (exp (name length) ( (exp src) )) - (exp (exp soffs) + (exp 1))) )))) end)) (statement (functionDeclaration function (name copy!) (parameters ( (parameter dest :: (typeExpression AbstractArray)) , (parameter doffs :: (typeExpression Integer)) , (parameter src :: (typeExpression AbstractArray)) , (parameter soffs :: (typeExpression Integer)) , (parameter n :: (typeExpression Integer)) )) (block (statement (exp (exp (exp n) == (exp 0)) && (exp return (exp dest)))) (statement (exp (exp (exp n) < (exp 0)) && (exp (name throw) ( (exp (name BoundsError) ( (exp src) , (exp n) )) )))) (statement (exp (exp soffs) + (exp (exp (exp (exp n) - (exp 1)) > (exp (name length) ( (exp src) ))) && (exp (name throw) ( (exp (name BoundsError) ( (exp src) , (exp (exp soffs) + (exp (exp n) - (exp 1))) )) ))))) (statement (exp (exp doffs) + (exp (exp (exp (exp n) - (exp 1)) > (exp (name length) ( (exp dest) ))) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp (exp doffs) + (exp (exp n) - (exp 1))) )) ))))) (statement (exp (exp (exp doffs) < (exp 1)) && (exp (name throw) ( (exp (name BoundsError) ( (exp dest) , (exp doffs) )) )))) (statement (exp (exp (exp soffs) < (exp 1)) && (exp (name throw) ( (exp (name BoundsError) ( (exp src) , (exp soffs) )) )))) (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp 0) : (exp ( (exp (exp n) - (exp 1)) ))) (block (statement (exp (exp (exp (exp dest) [ (exp (exp doffs) + (exp i)) ]) = (exp src)) [ (exp (exp soffs) + (exp i)) ]))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration (name copy) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (name copy!) ( (exp (name similar) ( (exp a) )) , (exp a) )))) (statement (functionDeclaration function (name copy!) (typeParameters { (typeParameter (exp (exp R) , (exp S))) }) (parameters ( (parameter B :: (typeExpression AbstractVecOrMat (typeParameters { (typeParameter (exp R)) }))) , (parameter ir_dest :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter jr_dest :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter A :: (typeExpression AbstractVecOrMat (typeParameters { (typeParameter (exp S)) }))) , (parameter ir_src :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter jr_src :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) )) (block (statement (exp if (exp (exp (name length) ( (exp ir_dest) )) != (exp (name length) ( (exp ir_src) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source and destination must have same size (got ") , (exp (name length) ( (exp ir_src) ))) , (exp " and ")) , (exp (name length) ( (exp ir_dest) ))) , (exp ")") )) )) )))) end)) (statement (exp if (exp (exp (name length) ( (exp jr_dest) )) != (exp (name length) ( (exp jr_src) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source and destination must have same size (got ") , (exp (name length) ( (exp jr_src) ))) , (exp " and ")) , (exp (name length) ( (exp jr_dest) ))) , (exp ")") )) )) )))) end)) (statement (exp (name checkbounds) ( (exp (exp B) , (exp ir_dest)) , (exp jr_dest) ))) (statement (exp (name checkbounds) ( (exp (exp A) , (exp ir_src)) , (exp jr_src) ))) (statement (exp (exp jdest) = (exp (name first) ( (exp jr_dest) )))) (statement (exp for (exp jsrc) in (exp jr_src) (block (statement (exp (exp idest) = (exp (name first) ( (exp ir_dest) )))) (statement (exp for (exp isrc) in (exp ir_src) (block (statement (exp (exp (exp (exp B) [ (exp idest) , (exp jdest) ]) = (exp A)) [ (exp isrc) , (exp jsrc) ])) (statement (exp (exp idest) += (exp (name step) ( (exp ir_dest) ))))) end)) (statement (exp (exp jdest) += (exp (name step) ( (exp jr_dest) ))))) end)) (statement (exp return (exp B)))) end)) (statement (functionDeclaration function (name copy_transpose!) (typeParameters { (typeParameter (exp (exp R) , (exp S))) }) (parameters ( (parameter B :: (typeExpression AbstractVecOrMat (typeParameters { (typeParameter (exp R)) }))) , (parameter ir_dest :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter jr_dest :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter A :: (typeExpression AbstractVecOrMat (typeParameters { (typeParameter (exp S)) }))) , (parameter ir_src :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) , (parameter jr_src :: (typeExpression Range (typeParameters { (typeParameter (exp Int)) }))) )) (block (statement (exp if (exp (exp (name length) ( (exp ir_dest) )) != (exp (name length) ( (exp jr_src) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source and destination must have same size (got ") , (exp (name length) ( (exp jr_src) ))) , (exp " and ")) , (exp (name length) ( (exp ir_dest) ))) , (exp ")") )) )) )))) end)) (statement (exp if (exp (exp (name length) ( (exp jr_dest) )) != (exp (name length) ( (exp ir_src) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp (name string) ( (exp (exp (exp (exp "source and destination must have same size (got ") , (exp (name length) ( (exp ir_src) ))) , (exp " and ")) , (exp (name length) ( (exp jr_dest) ))) , (exp ")") )) )) )))) end)) (statement (exp (name checkbounds) ( (exp (exp B) , (exp ir_dest)) , (exp jr_dest) ))) (statement (exp (name checkbounds) ( (exp (exp A) , (exp ir_src)) , (exp jr_src) ))) (statement (exp (exp idest) = (exp (name first) ( (exp ir_dest) )))) (statement (exp for (exp jsrc) in (exp jr_src) (block (statement (exp (exp jdest) = (exp (name first) ( (exp jr_dest) )))) (statement (exp for (exp isrc) in (exp ir_src) (block (statement (exp (exp (exp (exp B) [ (exp idest) , (exp jdest) ]) = (exp A)) [ (exp isrc) , (exp jsrc) ])) (statement (exp (exp jdest) += (exp (name step) ( (exp jr_dest) ))))) end)) (statement (exp (exp idest) += (exp (name step) ( (exp ir_dest) ))))) end)) (statement (exp return (exp B)))) end)) (statement (functionDeclaration (name zero) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter x :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name fill!) ( (exp (name similar) ( (exp x) )) , (exp (name zero) ( (exp T) )) )))) (statement (functionDeclaration (name start) (parameters ( (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp (exp @ (name _inline_meta) ( )) ; (exp (exp itr) = (exp (name eachindex) ( (exp A) )))) ; (exp ( (exp itr) , (exp (name start) ( (exp itr) )) ))) )))) (statement (functionDeclaration (name next) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter i) )) = (exp ( (exp (exp (exp @ (name _inline_meta) ( )) ; (exp (exp ( (exp idx) , (exp s) )) = (exp (name next) ( (exp (exp i) [ (exp 1) ]) , (exp (exp i) [ (exp 2) ]) )))) ; (exp ( (exp (exp A) [ (exp idx) ]) , (exp ( (exp (exp i) [ (exp 1) ]) , (exp s) )) ))) )))) (statement (functionDeclaration (name done) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter i) )) = (exp (name done) ( (exp (exp i) [ (exp 1) ]) , (exp (exp i) [ (exp 2) ]) )))) (statement (functionDeclaration (name iterstate) (parameters ( (parameter i) )) = (exp i))) (statement (functionDeclaration (name iterstate) (parameters ( (parameter i :: (typeExpression Tuple (typeParameters { (typeParameter (exp (exp (typeExpression UnitRange (typeParameters { (typeParameter (exp Int)) }))) , (exp Int))) }))) )) = (exp (exp i) [ (exp 2) ]))) (statement (functionDeclaration (name eachindex) (parameters ( (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp @ (name _inline_meta) ( )) ; (exp (name eachindex) ( (exp (name linearindexing) ( (exp A) )) , (exp A) ))) )))) (statement (functionDeclaration function (name eachindex) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp @ (name _inline_meta) (exp (name eachindex) ( (exp (exp (name linearindexing) ( (exp A) , (exp B) )) , (exp A)) , (exp B) ))))) end)) (statement (functionDeclaration function (name eachindex) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter B :: (typeExpression AbstractArray)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name eachindex) ( (exp (exp (name linearindexing) ( (exp A) , (exp (exp B) ...) )) , (exp A)) , (exp (exp B) ...) ))))) end)) (statement (functionDeclaration (name eachindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp (exp 1) : (exp (name length) ( (exp A) ))))) (statement (functionDeclaration function (name eachindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter B :: (typeExpression AbstractArray)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (exp 1) : (exp (name _maxlength) ( (exp A) , (exp (exp B) ...) )))))) end)) (statement (functionDeclaration (name _maxlength) (parameters ( (parameter A) )) = (exp (name length) ( (exp A) )))) (statement (functionDeclaration function (name _maxlength) (parameters ( (parameter A) , (parameter B) , (parameter (parameter C) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name max) ( (exp (name length) ( (exp A) )) , (exp (name _maxlength) ( (exp B) , (exp (exp C) ...) )) ))))) end)) (statement (functionDeclaration (name isempty) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp (name length) ( (exp a) )) == (exp 0)) )))) (statement (functionDeclaration (name convert) (typeParameters { (typeParameter (exp (exp T) , (exp N))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) })))) }))) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) }))) )) = (exp A))) (statement (functionDeclaration (name convert) (typeParameters { (typeParameter (exp (exp (exp T) , (exp S)) , (exp N))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) })))) }))) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp S) , (exp N))) }))) )) = (exp (name copy!) ( (exp (name similar) ( (exp A) , (exp T) )) , (exp A) )))) (statement (functionDeclaration (name convert) (typeParameters { (typeParameter (exp (exp (exp T) , (exp S)) , (exp N))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) })))) }))) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp S) , (exp N))) }))) )) = (exp (name convert) ( (exp (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) }))) , (exp A) )))) (statement (functionDeclaration (name convert) (typeParameters { (typeParameter (exp (exp T) , (exp N))) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Array)) }))) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp N))) }))) )) = (exp (name convert) ( (exp (typeExpression Array (typeParameters { (typeParameter (exp (exp T) , (exp N))) }))) , (exp A) )))) (statement (functionDeclaration (name full) (parameters ( (parameter x :: (typeExpression AbstractArray)) )) = (exp x))) (statement (functionDeclaration (name map) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Integer)) }))) , (parameter a :: (typeExpression Array)) )) = (exp (name map!) ( (exp (exp Integer) , (exp (name similar) ( (exp a) , (exp (name typeof) ( (exp (name Integer) ( (exp (name one) ( (exp (name eltype) ( (exp a) )) )) )) )) ))) , (exp a) )))) (statement (functionDeclaration (name map) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Signed)) }))) , (parameter a :: (typeExpression Array)) )) = (exp (name map!) ( (exp (exp Signed) , (exp (name similar) ( (exp a) , (exp (name typeof) ( (exp (name Signed) ( (exp (name one) ( (exp (name eltype) ( (exp a) )) )) )) )) ))) , (exp a) )))) (statement (functionDeclaration (name map) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp Unsigned)) }))) , (parameter a :: (typeExpression Array)) )) = (exp (name map!) ( (exp (exp Unsigned) , (exp (name similar) ( (exp a) , (exp (name typeof) ( (exp (name Unsigned) ( (exp (name one) ( (exp (name eltype) ( (exp a) )) )) )) )) ))) , (exp a) )))) (statement (functionDeclaration (name map) (typeParameters { (typeParameter T <: (typeExpression Real)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) , (parameter r :: (typeExpression StepRange)) )) = (exp (exp (exp (name T) ( (exp (exp r) . (exp start)) )) : (exp (name T) ( (exp (exp r) . (exp step)) ))) : (exp (name T) ( (exp (name last) ( (exp r) )) ))))) (statement (functionDeclaration (name map) (typeParameters { (typeParameter T <: (typeExpression Real)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) , (parameter r :: (typeExpression UnitRange)) )) = (exp (exp (name T) ( (exp (exp r) . (exp start)) )) : (exp (name T) ( (exp (name last) ( (exp r) )) ))))) (statement (functionDeclaration (name map) (typeParameters { (typeParameter T <: (typeExpression AbstractFloat)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) , (parameter r :: (typeExpression FloatRange)) )) = (exp (name FloatRange) ( (exp (exp (exp (name T) ( (exp (exp r) . (exp start)) )) , (exp (name T) ( (exp (exp r) . (exp step)) ))) , (exp (exp r) . (exp len))) , (exp (name T) ( (exp (exp r) . (exp divisor)) )) )))) (statement (functionDeclaration function (name map) (typeParameters { (typeParameter T <: (typeExpression AbstractFloat)) }) (parameters ( (parameter :: (typeExpression Type (typeParameters { (typeParameter (exp T)) }))) , (parameter r :: (typeExpression LinSpace)) )) (block (statement (exp (exp new_len) = (exp (name T) ( (exp (exp r) . (exp len)) )))) (statement (exp (exp (exp new_len) == (exp (exp r) . (exp len))) || (exp (name error) ( (exp "$r: too long for $T") )))) (statement (exp (name LinSpace) ( (exp (exp (exp (name T) ( (exp (exp r) . (exp start)) )) , (exp (name T) ( (exp (exp r) . (exp stop)) ))) , (exp new_len)) , (exp (name T) ( (exp (exp r) . (exp divisor)) )) )))) end)) (statement (functionDeclaration (name pointer) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter x :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) )) = (exp (name unsafe_convert) ( (exp (typeExpression Ptr (typeParameters { (typeParameter (exp T)) }))) , (exp x) )))) (statement (functionDeclaration (name pointer) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter x :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter i :: (typeExpression Integer)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (exp (name unsafe_convert) ( (exp (typeExpression Ptr (typeParameters { (typeParameter (exp T)) }))) , (exp x) )) + (exp (exp ( (exp (exp i) - (exp 1)) )) * (exp (name elsize) ( (exp x) ))))) )))) (statement (functionDeclaration function (name getindex) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name _getindex) ( (exp (exp (name linearindexing) ( (exp A) )) , (exp A)) , (exp (exp I) ...) ))))) end)) (statement (functionDeclaration function (name unsafe_getindex) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name _unsafe_getindex) ( (exp (exp (name linearindexing) ( (exp A) )) , (exp A)) , (exp (exp I) ...) ))))) end)) (statement (functionDeclaration (name _getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name getindex) ( (exp A) , (exp 1) ))) )))) (statement (functionDeclaration (name _getindex) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 0))) }))) )) = (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration (name _getindex) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractVector)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name getindex) ( (exp A) , (exp 1) ))) )))) (statement (functionDeclaration (name _getindex) (parameters ( (parameter l :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name _getindex) ( (exp (exp l) , (exp A)) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name unsafe_getindex) ( (exp A) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_getindex) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 0))) }))) )) = (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration (name _unsafe_getindex) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractVector)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name unsafe_getindex) ( (exp A) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_getindex) (parameters ( (parameter l :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name _unsafe_getindex) ( (exp (exp l) , (exp A)) , (exp 1) ))) )))) (statement (functionDeclaration (name _getindex) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) = (exp (name error) ( (exp "indexing $(typeof(A)) with types $(typeof(I)) is not supported") )))) (statement (functionDeclaration (name _unsafe_getindex) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I) ...) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name getindex) ( (exp A) , (exp (exp I) ...) ))) )))) (statement (functionDeclaration (name _getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Int)) )) = (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration function (name _getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (exp J) = (exp (name to_indexes) ( (exp (exp I) ...) ))) (exp (name checkbounds) ( (exp A) , (exp (exp J) ...) )) (exp (name unsafe_getindex) ( (exp A) , (exp (name sub2ind) ( (exp (name size) ( (exp A) )) , (exp (exp J) ...) )) ))))) end)) (statement (functionDeclaration (name _unsafe_getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Real)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name getindex) ( (exp A) , (exp I) ))) )))) (statement (functionDeclaration function (name _unsafe_getindex) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name unsafe_getindex) ( (exp A) , (exp (name sub2ind) ( (exp (name size) ( (exp A) )) , (exp (exp (name to_indexes) ( (exp (exp I) ...) )) ...) )) ))))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _getindex) (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }))) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp (exp N) = (exp (name length) ( (exp I) )))) (statement (exp if (exp (exp N) == (exp AN)) (block (statement (exp if (exp (exp (name all) ( (exp (exp x) -> (exp (exp x) === (exp Int))) , (exp I) )) : (exp ( (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )) ))) block else (block (statement (exp : (exp ( (exp (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) ))) ; (exp (name getindex) ( (exp A) , (exp (exp (name to_indexes) ( (exp (exp I) ...) )) ...) ))) ))))) end))) elseif (exp (exp N) > (exp AN)) (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp AN)) ])) (statement (exp (exp Osplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp (name to_index) ( (exp (exp I) [ (exp $ (exp d)) ]) )) == (exp 1)) ))) for (exp d) = (exp (exp AN) + (exp (exp 1) : (exp N))) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement exp) (statement (exp ( & ))) (statement (exp (exp ( (exp $ (exp ( (exp (exp Osplat) ...) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp I) )))) (statement (exp (name getindex) ( (exp A) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) else (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp (exp N) - (exp 1))) ])) (statement (exp (exp i) = (exp 0))) (statement (exp for (exp d) = (exp (exp N) : (exp AN)) (block (statement (exp (name push!) ( (exp Isplat) , (exp : (exp ( (exp (exp s) [ (exp $ (exp ( (exp (exp i) += (exp 1)) ))) ]) ))) )))) end)) (statement (exp (exp sz) = (exp (name Expr) ( (exp : (exp tuple)) )))) (statement (exp (exp (exp sz) . (exp args)) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (name size) ( (exp A) , (exp $ (exp d)) )) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp (exp szcheck) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp (name size) ( (exp A) , (exp $ (exp d)) )) > (exp 0)) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement exp) (statement (exp ( & ))) (statement (exp (exp ( (exp $ (exp ( (exp (exp szcheck) ...) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp I) )))) (statement (exp (exp s) = (exp (name ind2sub) ( (exp $ (exp sz)) , (exp (name to_index) ( (exp (exp I) [ (exp $ (exp N)) ]) )) )))) (statement (exp (name getindex) ( (exp A) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) end))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _unsafe_getindex) (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }))) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp (exp N) = (exp (name length) ( (exp I) )))) (statement (exp if (exp (exp N) == (exp (exp AN) : (exp ( (exp (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) ))) ; (exp (name getindex) ( (exp A) , (exp (exp I) ...) ))) )))) block elseif (exp (exp N) > (exp AN)) (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement (exp (name unsafe_getindex) ( (exp A) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) else (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp (exp N) - (exp 1))) ])) (statement (exp for (exp d) = (exp (exp N) : (exp AN)) (block (statement (exp (name push!) ( (exp Isplat) , (exp : (exp ( (exp (exp s) [ (exp $ (exp ( (exp (exp d) - (exp (exp N) + (exp 1))) ))) ]) ))) )))) end)) (statement (exp (exp sz) = (exp (name Expr) ( (exp : (exp tuple)) )))) (statement (exp (exp (exp sz) . (exp args)) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (name size) ( (exp A) , (exp $ (exp d)) )) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement (exp (exp s) = (exp (name ind2sub) ( (exp $ (exp sz)) , (exp (name to_index) ( (exp (exp I) [ (exp $ (exp N)) ]) )) )))) (statement (exp (name unsafe_getindex) ( (exp A) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) end))) end)) (statement (functionDeclaration function (name setindex!) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name _setindex!) ( (exp (exp (exp (name linearindexing) ( (exp A) )) , (exp A)) , (exp v)) , (exp (exp I) ...) ))))) end)) (statement (functionDeclaration function (name unsafe_setindex!) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name _unsafe_setindex!) ( (exp (exp (exp (name linearindexing) ( (exp A) )) , (exp A)) , (exp v)) , (exp (exp I) ...) ))))) end)) (statement (functionDeclaration (name _setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _setindex!) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 0))) }))) , (parameter v) )) = (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration (name _setindex!) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractVector)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _setindex!) (parameters ( (parameter l :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name _setindex!) ( (exp (exp (exp l) , (exp A)) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_setindex!) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp 0))) }))) , (parameter v) )) = (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration (name _unsafe_setindex!) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractVector)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _unsafe_setindex!) (parameters ( (parameter l :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name _unsafe_setindex!) ( (exp (exp (exp l) , (exp A)) , (exp v)) , (exp 1) ))) )))) (statement (functionDeclaration (name _setindex!) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I) ...) )) = (exp (name error) ( (exp "indexing $(typeof(A)) with types $(typeof(I)) is not supported") )))) (statement (functionDeclaration (name _unsafe_setindex!) (parameters ( (parameter :: (typeExpression LinearIndexing)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I) ...) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp (exp I) ...) ))) )))) (statement (functionDeclaration (name _setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter I :: (typeExpression Int)) )) = (exp (name error) ( (exp "indexed assignment not defined for ") , (exp (name typeof) ( (exp A) )) )))) (statement (functionDeclaration function (name _setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (exp J) = (exp (name to_indexes) ( (exp (exp I) ...) ))) (exp (name checkbounds) ( (exp A) , (exp (exp J) ...) )) (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp (name sub2ind) ( (exp (name size) ( (exp A) )) , (exp (exp J) ...) )) ))))) end)) (statement (functionDeclaration (name _unsafe_setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter I :: (typeExpression Real)) )) = (exp ( (exp (exp @ (name _inline_meta)) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp I) ))) )))) (statement (functionDeclaration function (name _unsafe_setindex!) (parameters ( (parameter :: (typeExpression LinearFast)) , (parameter A :: (typeExpression AbstractArray)) , (parameter v) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp @ (name _inline_meta) (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp (name sub2ind) ( (exp (name size) ( (exp A) )) , (exp (exp (name to_indexes) ( (exp (exp I) ...) )) ...) )) ))))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _setindex!) (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }))) , (parameter v) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp (exp N) = (exp (name length) ( (exp I) )))) (statement (exp if (exp (exp N) == (exp AN)) (block (statement (exp if (exp (exp (name all) ( (exp (exp x) -> (exp (exp x) === (exp Int))) , (exp I) )) : (exp ( (exp (name error) ( (exp "indexing not defined for ") , (exp (name typeof) ( (exp A) )) )) ))) block else (block (statement (exp : (exp ( (exp (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) ))) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp (exp (name to_indexes) ( (exp (exp I) ...) )) ...) ))) ))))) end))) elseif (exp (exp N) > (exp AN)) (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp AN)) ])) (statement (exp (exp Osplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp (name to_index) ( (exp (exp I) [ (exp $ (exp d)) ]) )) == (exp 1)) ))) for (exp d) = (exp (exp AN) + (exp (exp 1) : (exp N))) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement exp) (statement (exp ( & ))) (statement (exp (exp ( (exp $ (exp ( (exp (exp Osplat) ...) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp I) )))) (statement (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) else (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp (exp N) - (exp 1))) ])) (statement (exp (exp i) = (exp 0))) (statement (exp for (exp d) = (exp (exp N) : (exp AN)) (block (statement (exp (name push!) ( (exp Isplat) , (exp : (exp ( (exp (exp s) [ (exp $ (exp ( (exp (exp i) += (exp 1)) ))) ]) ))) )))) end)) (statement (exp (exp sz) = (exp (name Expr) ( (exp : (exp tuple)) )))) (statement (exp (exp (exp sz) . (exp args)) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (name size) ( (exp A) , (exp $ (exp d)) )) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp (exp szcheck) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp (name size) ( (exp A) , (exp $ (exp d)) )) > (exp 0)) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement exp) (statement (exp ( & ))) (statement (exp (exp ( (exp $ (exp ( (exp (exp szcheck) ...) ))) )) || (exp (name throw_boundserror) ( (exp A) , (exp I) )))) (statement (exp (exp s) = (exp (name ind2sub) ( (exp $ (exp sz)) , (exp (name to_index) ( (exp (exp I) [ (exp $ (exp N)) ]) )) )))) (statement (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) end))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _unsafe_setindex!) (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }) (parameters ( (parameter :: (typeExpression LinearSlow)) , (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp (exp T) , (exp AN))) }))) , (parameter v) , (parameter (parameter I :: (typeExpression Real)) ...) )) (block (statement (exp (exp N) = (exp (name length) ( (exp I) )))) (statement (exp if (exp (exp N) == (exp (exp AN) : (exp ( (exp (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) ))) ; (exp (name setindex!) ( (exp (exp A) , (exp v)) , (exp (exp I) ...) ))) )))) block elseif (exp (exp N) > (exp AN)) (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) else (block (statement (exp (exp Isplat) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (exp I) [ (exp $ (exp d)) ]) ))) for (exp d) = (exp (exp 1) : (exp (exp N) - (exp 1))) ])) (statement (exp for (exp d) = (exp (exp N) : (exp AN)) (block (statement (exp (name push!) ( (exp Isplat) , (exp : (exp ( (exp (exp s) [ (exp $ (exp ( (exp (exp d) - (exp (exp N) + (exp 1))) ))) ]) ))) )))) end)) (statement (exp (exp sz) = (exp (name Expr) ( (exp : (exp tuple)) )))) (statement (exp (exp (exp sz) . (exp args)) = (exp Expr))) (statement (exp [ (exp : (exp ( (exp (name size) ( (exp A) , (exp $ (exp d)) )) ))) for (exp d) = (exp (exp N) : (exp AN)) ])) (statement (exp quote (block (statement (exp $ (exp ( (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )) )))) (statement (exp (exp s) = (exp (name ind2sub) ( (exp $ (exp sz)) , (exp (name to_index) ( (exp (exp I) [ (exp $ (exp N)) ]) )) )))) (statement (exp (name unsafe_setindex!) ( (exp (exp A) , (exp v)) , (exp $ (exp ( (exp (exp Isplat) ...) ))) )))) end))) end))) end)) (statement (typeDeclaration typealias RangeVecIntList (typeParameters { (typeParameter A <: (typeExpression AbstractVector (typeParameters { (typeParameter (exp Int)) }))) }) (typeExpression Union { (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp (typeExpression Union { (typeExpression Range) , (typeExpression AbstractVector (typeParameters { (typeParameter (exp Int)) })) }))) })))) })) , (typeExpression AbstractVector (typeParameters { (typeParameter (exp (typeExpression UnitRange (typeParameters { (typeParameter (exp Int)) })))) })) , (typeExpression AbstractVector (typeParameters { (typeParameter (exp (typeExpression Range (typeParameters { (typeParameter (exp Int)) })))) })) , (typeExpression AbstractVector (typeParameters { (typeParameter (exp A)) })) }))) (statement (functionDeclaration (name get) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter i :: (typeExpression Integer)) , (parameter default) )) = (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name length) ( (exp A) ))) , (exp i) )) ? (exp (exp A) [ (exp i) ]) : (exp default)))) (statement (functionDeclaration (name get) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Tuple (typeParameters { }))) , (parameter default) )) = (exp (name similar) ( (exp (exp A) , (exp (name typeof) ( (exp default) ))) , (exp 0) )))) (statement (functionDeclaration (name get) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Dims)) , (parameter default) )) = (exp (exp (name checkbounds) ( (exp (exp Bool) , (exp (name size) ( (exp A) ))) , (exp (exp I) ...) )) ? (exp (exp A) [ (exp (exp I) ...) ]) : (exp default)))) (statement (functionDeclaration function (name get!) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter X :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Union { (typeExpression Range) , (typeExpression AbstractVector (typeParameters { (typeParameter (exp Int)) })) })) , (parameter default :: (typeExpression T)) )) (block (statement (exp (exp ind) = (exp (name findin) ( (exp I) , (exp (exp 1) : (exp (name length) ( (exp A) ))) )))) (statement (exp (exp (exp (exp X) [ (exp ind) ]) = (exp A)) [ (exp (exp I) [ (exp ind) ]) ])) (statement (exp (exp (exp X) [ (exp (exp 1) : (exp (exp (name first) ( (exp ind) )) - (exp 1))) ]) = (exp default))) (statement (exp (exp (exp X) [ (exp (exp (name last) ( (exp ind) )) + (exp (exp 1) : (exp (name length) ( (exp X) )))) ]) = (exp default))) (statement (exp X))) end)) (statement (functionDeclaration (name get) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression Range)) , (parameter default) )) = (exp (name get!) ( (exp (exp (exp (name similar) ( (exp (exp A) , (exp (name typeof) ( (exp default) ))) , (exp (name length) ( (exp I) )) )) , (exp A)) , (exp I)) , (exp default) )))) (statement (functionDeclaration function (name get!) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter X :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression RangeVecIntList)) , (parameter default :: (typeExpression T)) )) (block (statement (exp (name fill!) ( (exp X) , (exp default) ))) (statement (exp (exp dst) , (exp (exp src) = (exp (name indcopy) ( (exp (name size) ( (exp A) )) , (exp I) ))))) (statement (exp (exp (exp (exp X) [ (exp (exp dst) ...) ]) = (exp A)) [ (exp (exp src) ...) ])) (statement (exp X))) end)) (statement (functionDeclaration (name get) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter I :: (typeExpression RangeVecIntList)) , (parameter default) )) = (exp (name get!) ( (exp (exp (exp (name similar) ( (exp (exp A) , (exp (name typeof) ( (exp default) ))) , (exp (exp (name map) ( (exp length) , (exp I) )) ...) )) , (exp A)) , (exp I)) , (exp default) )))) (statement (functionDeclaration (name promote_eltype) (parameters ( )) = (exp Bottom))) (statement (functionDeclaration (name promote_eltype) (parameters ( (parameter v1) , (parameter (parameter vs) ...) )) = (exp (name promote_type) ( (exp (name eltype) ( (exp v1) )) , (exp (name promote_eltype) ( (exp (exp vs) ...) )) )))) (statement (functionDeclaration (name cat) (parameters ( (parameter catdim :: (typeExpression Integer)) )) = (exp (name Array) ( (exp Any) , (exp 0) )))) (statement (functionDeclaration (name vcat) (parameters ( )) = (exp (name Array) ( (exp Any) , (exp 0) )))) (statement (functionDeclaration (name hcat) (parameters ( )) = (exp (name Array) ( (exp Any) , (exp 0) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) )) = (exp (name Array) ( (exp T) , (exp 0) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) )) = (exp (name Array) ( (exp T) , (exp 0) )))) (statement (functionDeclaration (name vcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp i) ]) for (exp i) = (exp (exp 1) : (exp (name length) ( (exp X) ))) ])) (statement (functionDeclaration (name vcat) (typeParameters { (typeParameter T <: (typeExpression Number)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp i) ]) for (exp i) = (exp (exp 1) : (exp (name length) ( (exp X) ))) ])) (statement (functionDeclaration (name hcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp j) ]) for (exp (exp (exp i) = (exp 1)) , (exp j)) = (exp (exp 1) : (exp (name length) ( (exp X) ))) ])) (statement (functionDeclaration (name hcat) (typeParameters { (typeParameter T <: (typeExpression Number)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp j) ]) for (exp (exp (exp i) = (exp 1)) , (exp j)) = (exp (exp 1) : (exp (name length) ( (exp X) ))) ])) (statement (functionDeclaration (name vcat) (parameters ( (parameter (parameter X :: (typeExpression Number)) ...) )) = (exp (name hvcat_fill) ( (exp (name Array) ( (exp (name promote_typeof) ( (exp (exp X) ...) )) , (exp (name length) ( (exp X) )) )) , (exp X) )))) (statement (functionDeclaration (name hcat) (parameters ( (parameter (parameter X :: (typeExpression Number)) ...) )) = (exp (name hvcat_fill) ( (exp (name Array) ( (exp (exp (name promote_typeof) ( (exp (exp X) ...) )) , (exp 1)) , (exp (name length) ( (exp X) )) )) , (exp X) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter X :: (typeExpression Number)) ...) )) = (exp (name hvcat_fill) ( (exp (name Array) ( (exp T) , (exp (name length) ( (exp X) )) )) , (exp X) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter X :: (typeExpression Number)) ...) )) = (exp (name hvcat_fill) ( (exp (name Array) ( (exp (exp T) , (exp 1)) , (exp (name length) ( (exp X) )) )) , (exp X) )))) (statement (functionDeclaration (name vcat) (parameters ( (parameter (parameter V :: (typeExpression AbstractVector)) ...) )) = (exp (name typed_vcat) ( (exp (name promote_eltype) ( (exp (exp V) ...) )) , (exp (exp V) ...) )))) (statement (functionDeclaration (name vcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter V :: (typeExpression AbstractVector (typeParameters { (typeParameter (exp T)) }))) ...) )) = (exp (name typed_vcat) ( (exp T) , (exp (exp V) ...) )))) (statement (functionDeclaration function (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter V :: (typeExpression AbstractVector)) ...) )) (block (statement (exp (exp (exp n) :: (typeExpression Int)) = (exp 0))) (statement (exp for (exp Vk) in (exp V) (block (statement (exp (exp n) += (exp (name length) ( (exp Vk) ))))) end)) (statement (exp (exp a) = (exp (name similar) ( (exp (exp (name full) ( (exp (exp V) [ (exp 1) ]) )) , (exp T)) , (exp n) )))) (statement (exp (exp pos) = (exp 1))) (statement (exp for (exp k) = (exp (exp 1) : (exp (name length) ( (exp V) ))) (block (statement (exp (exp (exp Vk) = (exp V)) [ (exp k) ])) (statement (exp (exp p1) = (exp (exp pos) + (exp (exp (name length) ( (exp Vk) )) - (exp 1))))) (statement (exp (exp (exp a) [ (exp (exp pos) : (exp p1)) ]) = (exp Vk))) (statement (exp (exp pos) = (exp (exp p1) + (exp 1))))) end)) (statement (exp a))) end)) (statement (functionDeclaration (name hcat) (parameters ( (parameter (parameter A :: (typeExpression AbstractVecOrMat)) ...) )) = (exp (name typed_hcat) ( (exp (name promote_eltype) ( (exp (exp A) ...) )) , (exp (exp A) ...) )))) (statement (functionDeclaration (name hcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter A :: (typeExpression AbstractVecOrMat (typeParameters { (typeParameter (exp T)) }))) ...) )) = (exp (name typed_hcat) ( (exp T) , (exp (exp A) ...) )))) (statement (functionDeclaration function (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter A :: (typeExpression AbstractVecOrMat)) ...) )) (block (statement (exp (exp nargs) = (exp (name length) ( (exp A) )))) (statement (exp (exp nrows) = (exp (name size) ( (exp (exp A) [ (exp 1) ]) , (exp 1) )))) (statement (exp (exp ncols) = (exp 0))) (statement (exp (exp dense) = (exp true))) (statement (exp for (exp j) = (exp (exp 1) : (exp nargs)) (block (statement (exp (exp (exp Aj) = (exp A)) [ (exp j) ])) (statement (exp if (exp (exp (name size) ( (exp Aj) , (exp 1) )) != (exp nrows)) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "number of rows of each array must match (got $(map(x->size(x,1), A)))") )) )))) end)) (statement (exp (exp dense) &= (exp (name isa) ( (exp Aj) , (exp Array) )))) (statement (exp (exp nd) = (exp (name ndims) ( (exp Aj) )))) (statement (exp (exp ncols) += (exp ( (exp (exp (exp nd) == (exp 2)) ? (exp (name size) ( (exp Aj) , (exp 2) )) : (exp 1)) ))))) end)) (statement (exp (exp B) = (exp (name similar) ( (exp (exp (exp (name full) ( (exp (exp A) [ (exp 1) ]) )) , (exp T)) , (exp nrows)) , (exp ncols) )))) (statement (exp (exp pos) = (exp 1))) (statement (exp if (exp dense) (block (statement (exp for (exp k) = (exp (exp 1) : (exp nargs)) (block (statement (exp (exp (exp Ak) = (exp A)) [ (exp k) ])) (statement (exp (exp n) = (exp (name length) ( (exp Ak) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp B) , (exp pos)) , (exp Ak)) , (exp 1)) , (exp n) ))) (statement (exp (exp pos) += (exp n)))) end))) else (block (statement (exp for (exp k) = (exp (exp 1) : (exp nargs)) (block (statement (exp (exp (exp Ak) = (exp A)) [ (exp k) ])) (statement (exp (exp p1) = (exp (exp pos) + (exp (exp ( (exp (exp (name isa) ( (exp Ak) , (exp AbstractMatrix) )) ? (exp (name size) ( (exp Ak) , (exp 2) )) : (exp 1)) )) - (exp 1))))) (statement (exp B)) (statement exp) (statement (exp [)) (statement (exp : ,)) (statement (exp pos)) (statement exp) (statement (exp :)) (statement (exp p1 ] =)) (statement (exp Ak)) (statement (exp (exp pos) = (exp (exp p1) + (exp 1))))) end))) end)) (statement (exp return (exp B)))) end)) (statement (functionDeclaration (name vcat) (parameters ( (parameter (parameter A :: (typeExpression AbstractMatrix)) ...) )) = (exp (name typed_vcat) ( (exp (name promote_eltype) ( (exp (exp A) ...) )) , (exp (exp A) ...) )))) (statement (functionDeclaration (name vcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter A :: (typeExpression AbstractMatrix (typeParameters { (typeParameter (exp T)) }))) ...) )) = (exp (name typed_vcat) ( (exp T) , (exp (exp A) ...) )))) (statement (functionDeclaration function (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter A :: (typeExpression AbstractMatrix)) ...) )) (block (statement (exp (exp nargs) = (exp (name length) ( (exp A) )))) (statement (exp (exp nrows) = (exp (exp (name sum) ( (exp (exp a) -> (exp (name size) ( (exp a) , (exp 1) ))) , (exp A) )) :: (typeExpression Int)))) (statement (exp (exp ncols) = (exp (name size) ( (exp (exp A) [ (exp 1) ]) , (exp 2) )))) (statement (exp for (exp j) = (exp (exp 2) : (exp nargs)) (block (statement (exp if (exp (exp (name size) ( (exp (exp A) [ (exp j) ]) , (exp 2) )) != (exp ncols)) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "number of columns of each array must match (got $(map(x->size(x,2), A)))") )) )))) end))) end)) (statement (exp (exp B) = (exp (name similar) ( (exp (exp (exp (name full) ( (exp (exp A) [ (exp 1) ]) )) , (exp T)) , (exp nrows)) , (exp ncols) )))) (statement (exp (exp pos) = (exp 1))) (statement (exp for (exp k) = (exp (exp 1) : (exp nargs)) (block (statement (exp (exp (exp Ak) = (exp A)) [ (exp k) ])) (statement (exp (exp p1) = (exp (exp pos) + (exp (exp (name size) ( (exp Ak) , (exp 1) )) - (exp 1))))) (statement (exp B)) (statement exp) (statement (exp [)) (statement (exp pos)) (statement exp) (statement (exp :)) (statement (exp p1)) , (statement exp) (statement (exp : ] =)) (statement (exp Ak)) (statement (exp (exp pos) = (exp (exp p1) + (exp 1))))) end)) (statement (exp return (exp B)))) end)) (statement (functionDeclaration function (name cat) (parameters ( (parameter catdims) , (parameter (parameter X) ...) )) (block (statement (exp (exp T) = (exp (name promote_type) ( (exp (exp (name map) ( (exp (exp x) -> (exp (exp (name isa) ( (exp x) , (exp AbstractArray) )) ? (exp (name eltype) ( (exp x) )) : (exp (name typeof) ( (exp x) )))) , (exp X) )) ...) )))) (statement (exp (name cat_t) ( (exp (exp catdims) , (exp T)) , (exp (exp X) ...) )))) end)) (statement (functionDeclaration function (name cat_t) (parameters ( (parameter catdims) , (parameter typeC :: (typeExpression Type)) , (parameter (parameter X) ...) )) (block (statement (exp (exp catdims) = (exp (name collect) ( (exp catdims) )))) (statement (exp (exp nargs) = (exp (name length) ( (exp X) )))) (statement (exp (exp ndimsX) = (exp Int))) (statement (exp [ (exp (exp (name isa) ( (exp a) , (exp AbstractArray) )) ? (exp (name ndims) ( (exp a) )) : (exp 0)) for (exp a) in (exp X) ])) (statement (exp (exp ndimsC) = (exp (name max) ( (exp (name maximum) ( (exp ndimsX) )) , (exp (name maximum) ( (exp catdims) )) )))) (statement (exp (exp catsizes) = (exp (name zeros) ( (exp Int) , (exp ( (exp nargs) , (exp (name length) ( (exp catdims) )) )) )))) (statement (exp (exp dims2cat) = (exp (name zeros) ( (exp Int) , (exp ndimsC) )))) (statement (exp for (exp k) = (exp (exp 1) : (exp (name length) ( (exp catdims) ))) (block (statement (exp (exp (exp dims2cat) [ (exp (exp catdims) [ (exp k) ]) ]) = (exp k)))) end)) (statement (exp (exp dimsC) = (exp Int))) (statement (exp [ (exp (exp (exp (exp d) <= (exp ndimsX)) [ (exp 1) ]) ? (exp (name size) ( (exp (exp X) [ (exp 1) ]) , (exp d) )) : (exp 1)) for (exp d) = (exp (exp 1) : (exp ndimsC)) ])) (statement (exp for (exp k) = (exp (exp 1) : (exp (name length) ( (exp catdims) ))) (block (statement (exp (exp (exp (exp catsizes) [ (exp 1) , (exp k) ]) = (exp dimsC)) [ (exp (exp catdims) [ (exp k) ]) ]))) end)) (statement (exp for (exp i) = (exp (exp 2) : (exp nargs)) (block (statement (exp for (exp d) = (exp (exp 1) : (exp ndimsC)) (block (statement (exp (exp currentdim) = (exp ( (exp (exp (exp (exp d) <= (exp ndimsX)) [ (exp i) ]) ? (exp (name size) ( (exp (exp X) [ (exp i) ]) , (exp d) )) : (exp 1)) )))) (statement (exp if (exp (exp (exp dims2cat) [ (exp d) ]) != (exp 0)) (block (statement (exp (exp (exp dimsC) [ (exp d) ]) += (exp currentdim))) (statement (exp (exp (exp catsizes) [ (exp i) , (exp (exp dims2cat) [ (exp d) ]) ]) = (exp currentdim)))) elseif (exp (exp (exp dimsC) [ (exp d) ]) != (exp currentdim)) (block (statement (exp (name throw) ( (exp (name DimensionMismatch) ( (exp (name string) ( (exp (exp (exp (exp (exp (exp "mismatch in dimension ") , (exp d)) , (exp " (expected ")) , (exp (exp dimsC) [ (exp d) ])) , (exp " got ")) , (exp currentdim)) , (exp ")") )) )) )))) end))) end))) end)) (statement (exp (exp C) = (exp (name similar) ( (exp (exp (exp (name isa) ( (exp (exp X) [ (exp 1) ]) , (exp AbstractArray) )) ? (exp (name full) ( (exp (exp X) [ (exp 1) ]) )) : (exp [ (exp (exp X) [ (exp 1) ]) ])) , (exp typeC)) , (exp (name tuple) ( (exp (exp dimsC) ...) )) )))) (statement (exp if (exp (exp (name length) ( (exp catdims) )) > (exp 1)) (block (statement (exp (name fill!) ( (exp C) , (exp 0) )))) end)) (statement (exp (exp offsets) = (exp (name zeros) ( (exp Int) , (exp (name length) ( (exp catdims) )) )))) (statement (exp for (exp i) = (exp (exp 1) : (exp nargs)) (block (statement (exp (exp cat_one) = (exp [ (exp (exp (exp (exp dims2cat) [ (exp d) ]) == (exp 0)) ? (exp ( (exp (exp (exp 1) : (exp dimsC)) [ (exp d) ]) )) : (exp ( (exp (exp (exp offsets) [ (exp (exp dims2cat) [ (exp d) ]) ]) + (exp ( (exp (exp (exp 1) : (exp catsizes)) [ (exp i) , (exp (exp dims2cat) [ (exp d) ]) ]) ))) ))) for (exp d) = (exp (exp 1) : (exp ndimsC)) ]))) (statement (exp (exp (exp (exp C) [ (exp (exp cat_one) ...) ]) = (exp X)) [ (exp i) ])) (statement (exp for (exp k) = (exp (exp 1) : (exp (name length) ( (exp catdims) ))) (block (statement (exp (exp (exp (exp offsets) [ (exp k) ]) += (exp catsizes)) [ (exp i) , (exp k) ]))) end))) end)) (statement (exp return (exp C)))) end)) (statement (functionDeclaration (name vcat) (parameters ( (parameter (parameter X) ...) )) = (exp (name cat) ( (exp 1) , (exp (exp X) ...) )))) (statement (functionDeclaration (name hcat) (parameters ( (parameter (parameter X) ...) )) = (exp (name cat) ( (exp 2) , (exp (exp X) ...) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter X) ...) )) = (exp (name cat_t) ( (exp (exp 1) , (exp T)) , (exp (exp X) ...) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter X) ...) )) = (exp (name cat_t) ( (exp (exp 2) , (exp T)) , (exp (exp X) ...) )))) (statement (functionDeclaration (name cat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter catdims) , (parameter (parameter A :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) ...) )) = (exp (name cat_t) ( (exp (exp catdims) , (exp T)) , (exp (exp A) ...) )))) (statement (functionDeclaration (name cat) (parameters ( (parameter catdims) , (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) = (exp (name cat_t) ( (exp (exp catdims) , (exp (name promote_eltype) ( (exp (exp A) ...) ))) , (exp (exp A) ...) )))) (statement (functionDeclaration (name vcat) (parameters ( (parameter A :: (typeExpression AbstractArray)) )) = (exp (name cat) ( (exp 1) , (exp A) )))) (statement (functionDeclaration (name vcat) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) = (exp (name cat) ( (exp (exp 1) , (exp A)) , (exp B) )))) (statement (functionDeclaration (name vcat) (parameters ( (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) = (exp (name cat) ( (exp 1) , (exp (exp A) ...) )))) (statement (functionDeclaration (name hcat) (parameters ( (parameter A :: (typeExpression AbstractArray)) )) = (exp (name cat) ( (exp 2) , (exp A) )))) (statement (functionDeclaration (name hcat) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) = (exp (name cat) ( (exp (exp 2) , (exp A)) , (exp B) )))) (statement (functionDeclaration (name hcat) (parameters ( (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) = (exp (name cat) ( (exp 2) , (exp (exp A) ...) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp (name cat_t) ( (exp (exp 1) , (exp T)) , (exp A) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) = (exp (name cat_t) ( (exp (exp (exp 1) , (exp T)) , (exp A)) , (exp B) )))) (statement (functionDeclaration (name typed_vcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) = (exp (name cat_t) ( (exp (exp 1) , (exp T)) , (exp (exp A) ...) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp (name cat_t) ( (exp (exp 2) , (exp T)) , (exp A) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) = (exp (name cat_t) ( (exp (exp (exp 2) , (exp T)) , (exp A)) , (exp B) )))) (statement (functionDeclaration (name typed_hcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) = (exp (name cat_t) ( (exp (exp 2) , (exp T)) , (exp (exp A) ...) )))) (statement (functionDeclaration function (name hvcat) (parameters ( (parameter nbc :: (typeExpression Integer)) , (parameter (parameter as) ...) )) (block (statement (exp (exp n) = (exp (name length) ( (exp as) )))) (statement (exp (exp (exp (name mod) ( (exp n) , (exp nbc) )) != (exp 0)) && (exp (name throw) ( (exp (name ArgumentError) ( (exp "number of arrays $n is not a multiple of the requested number of block columns $nbc") )) )))) (statement (exp (exp nbr) = (exp (name div) ( (exp n) , (exp nbc) )))) (statement (exp (name hvcat) ( (exp (name ntuple) ( (exp (exp i) -> (exp nbc)) , (exp nbr) )) , (exp (exp as) ...) )))) end)) (statement (functionDeclaration function (name hvcat) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter as :: (typeExpression AbstractMatrix (typeParameters { (typeParameter (exp T)) }))) ...) )) (block (statement (exp (exp nbr) = (exp (name length) ( (exp rows) )))) (statement (exp (exp nc) = (exp 0))) (statement (exp for (exp i) = (exp (exp (exp 1) : (exp rows)) [ (exp 1) ]) (block (statement (exp (exp nc) += (exp (name size) ( (exp (exp as) [ (exp i) ]) , (exp 2) ))))) end)) (statement (exp (exp nr) = (exp 0))) (statement (exp (exp a) = (exp 1))) (statement (exp for (exp i) = (exp (exp 1) : (exp nbr)) (block (statement (exp (exp nr) += (exp (name size) ( (exp (exp as) [ (exp a) ]) , (exp 1) )))) (statement (exp (exp (exp a) += (exp rows)) [ (exp i) ]))) end)) (statement (exp (exp out) = (exp (name similar) ( (exp (exp (exp (name full) ( (exp (exp as) [ (exp 1) ]) )) , (exp T)) , (exp nr)) , (exp nc) )))) (statement (exp (exp a) = (exp 1))) (statement (exp (exp r) = (exp 1))) (statement (exp for (exp i) = (exp (exp 1) : (exp nbr)) (block (statement (exp (exp c) = (exp 1))) (statement (exp (exp szi) = (exp (name size) ( (exp (exp as) [ (exp a) ]) , (exp 1) )))) (statement (exp for (exp j) = (exp (exp (exp 1) : (exp rows)) [ (exp i) ]) (block (statement (exp (exp (exp Aj) = (exp as)) [ (exp (exp a) + (exp (exp j) - (exp 1))) ])) (statement (exp (exp szj) = (exp (name size) ( (exp Aj) , (exp 2) )))) (statement (exp if (exp (exp (name size) ( (exp Aj) , (exp 1) )) != (exp szi)) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "mismatched height in block row $(i) (expected $szi, got $(size(Aj,1)))") )) )))) end)) (statement (exp if (exp (exp c) - (exp (exp 1) + (exp (exp szj) > (exp nc)))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "block row $(i) has mismatched number of columns (expected $nc, got $(c-1+szj))") )) )))) end)) (statement (exp (exp (exp out) [ (exp (exp r) : (exp (exp r) - (exp (exp 1) + (exp szi)))) , (exp (exp c) : (exp (exp c) - (exp (exp 1) + (exp szj)))) ]) = (exp Aj))) (statement (exp (exp c) += (exp szj)))) end)) (statement (exp if (exp (exp c) != (exp (exp nc) + (exp 1))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "block row $(i) has mismatched number of columns (expected $nc, got $(c-1))") )) )))) end)) (statement (exp (exp r) += (exp szi))) (statement (exp (exp (exp a) += (exp rows)) [ (exp i) ]))) end)) (statement (exp out))) end)) (statement (functionDeclaration (name hvcat) (parameters ( (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) )) = (exp [ ]))) (statement (functionDeclaration function (name hvcat) (typeParameters { (typeParameter T <: (typeExpression Number)) }) (parameters ( (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter xs :: (typeExpression T)) ...) )) (block (statement (exp (exp nr) = (exp (name length) ( (exp rows) )))) (statement (exp (exp (exp nc) = (exp rows)) [ (exp 1) ])) (statement (exp (exp a) = (exp (name Array) ( (exp (exp T) , (exp nr)) , (exp nc) )))) (statement (exp if (exp (exp (name length) ( (exp a) )) != (exp (name length) ( (exp xs) ))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "argument count does not match specified shape (expected $(length(a)), got $(length(xs)))") )) )))) end)) (statement (exp (exp k) = (exp 1))) (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp 1) : (exp nr)) (block (statement (exp if (exp (exp (exp nc) != (exp rows)) [ (exp i) ]) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "row $(i) has mismatched number of columns (expected $nc, got $(rows[i]))") )) )))) end)) (statement (exp for (exp j) = (exp (exp 1) : (exp nc)) (block (statement (exp (exp (exp (exp a) [ (exp i) , (exp j) ]) = (exp xs)) [ (exp k) ])) (statement (exp (exp k) += (exp 1)))) end))) end) (exp a)))) end)) (statement (functionDeclaration function (name hvcat_fill) (parameters ( (parameter a) , (parameter xs) )) (block (statement (exp (exp k) = (exp 1))) (statement (exp (exp (exp nr) , (exp (exp nc) = (exp (name size) ( (exp a) , (exp 1) )))) , (exp (name size) ( (exp a) , (exp 2) )))) (statement (exp for (exp i) = (exp (exp 1) : (exp nr)) (block (statement (exp @ (name inbounds) (exp for (exp j) = (exp (exp 1) : (exp nc)) (block (statement (exp (exp (exp (exp a) [ (exp i) , (exp j) ]) = (exp xs)) [ (exp k) ])) (statement (exp (exp k) += (exp 1)))) end)))) end)) (statement (exp a))) end)) (statement (functionDeclaration function (name typed_hvcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter xs :: (typeExpression Number)) ...) )) (block (statement (exp (exp nr) = (exp (name length) ( (exp rows) )))) (statement (exp (exp (exp nc) = (exp rows)) [ (exp 1) ])) (statement (exp for (exp i) = (exp (exp 2) : (exp nr)) (block (statement (exp if (exp (exp (exp nc) != (exp rows)) [ (exp i) ]) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "row $(i) has mismatched number of columns (expected $nc, got $(rows[i]))") )) )))) end))) end)) (statement (exp (exp len) = (exp (name length) ( (exp xs) )))) (statement (exp if (exp (exp nr) * (exp (exp nc) != (exp len))) (block (statement (exp (name throw) ( (exp (name ArgumentError) ( (exp "argument count $(len) does not match specified shape $((nr,nc))") )) )))) end)) (statement (exp (name hvcat_fill) ( (exp (name Array) ( (exp (exp T) , (exp nr)) , (exp nc) )) , (exp xs) )))) end)) (statement (functionDeclaration function (name hvcat) (parameters ( (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter xs :: (typeExpression Number)) ...) )) (block (statement (exp (exp T) = (exp (name promote_typeof) ( (exp (exp xs) ...) )))) (statement (exp (name typed_hvcat) ( (exp (exp T) , (exp rows)) , (exp (exp xs) ...) )))) end)) (statement (functionDeclaration function (name hvcat) (parameters ( (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter as) ...) )) (block (statement (exp (exp nbr) = (exp (name length) ( (exp rows) )))) (statement (exp (exp rs) = (exp (name cell) ( (exp nbr) )))) (statement (exp (exp a) = (exp 1))) (statement (exp for (exp i) = (exp (exp 1) : (exp nbr)) (block (statement (exp (exp (exp rs) [ (exp i) ]) = (exp (name hcat) ( (exp (exp (exp as) [ (exp (exp a) : (exp (exp a) - (exp (exp 1) + (exp (exp rows) [ (exp i) ])))) ]) ...) )))) (statement (exp (exp (exp a) += (exp rows)) [ (exp i) ]))) end)) (statement (exp (name vcat) ( (exp (exp rs) ...) )))) end)) (statement (functionDeclaration function (name typed_hvcat) (parameters ( (parameter T :: (typeExpression Type)) , (parameter rows :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Int)) })))) }))) , (parameter (parameter as) ...) )) (block (statement (exp (exp nbr) = (exp (name length) ( (exp rows) )))) (statement (exp (exp rs) = (exp (name cell) ( (exp nbr) )))) (statement (exp (exp a) = (exp 1))) (statement (exp for (exp i) = (exp (exp 1) : (exp nbr)) (block (statement (exp (exp (exp rs) [ (exp i) ]) = (exp (name hcat) ( (exp (exp (exp as) [ (exp (exp a) : (exp (exp a) - (exp (exp 1) + (exp (exp rows) [ (exp i) ])))) ]) ...) )))) (statement (exp (exp (exp a) += (exp rows)) [ (exp i) ]))) end)) (statement (exp T)) (statement exp) (statement (exp [)) (statement (exp (exp rs) ...)) ; ]) end)) (statement (functionDeclaration function (name isequal) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp if (exp (exp A) === (exp B)) (block (statement (exp return (exp true)))) end)) (statement (exp if (exp (exp (name size) ( (exp A) )) != (exp (name size) ( (exp B) ))) (block (statement (exp return (exp false)))) end)) (statement (exp if (exp (exp (name isa) ( (exp A) , (exp Range) )) != (exp (name isa) ( (exp B) , (exp Range) ))) (block (statement (exp return (exp false)))) end)) (statement (exp for (exp i) in (exp (name eachindex) ( (exp A) , (exp B) )) (block (statement (exp if (exp ! (exp (name isequal) ( (exp (exp A) [ (exp i) ]) , (exp (exp B) [ (exp i) ]) ))) (block (statement (exp return (exp false)))) end))) end)) (statement (exp return (exp true)))) end)) (statement (functionDeclaration function (name lexcmp) (parameters ( (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp (exp (exp nA) , (exp (exp nB) = (exp (name length) ( (exp A) )))) , (exp (name length) ( (exp B) )))) (statement (exp for (exp i) = (exp (exp 1) : (exp (name min) ( (exp nA) , (exp nB) ))) (block (statement (exp (exp res) = (exp (name lexcmp) ( (exp (exp A) [ (exp i) ]) , (exp (exp B) [ (exp i) ]) )))) (statement (exp (exp (exp res) == (exp 0)) || (exp return (exp res))))) end)) (statement (exp return (exp (name cmp) ( (exp nA) , (exp nB) ))))) end)) (statement (functionDeclaration function (name <missing ID>) (parameters ( == )) (block (statement (exp ( (exp (exp A) :: (typeExpression AbstractArray)) , (exp (exp B) :: (typeExpression AbstractArray)) ))) (statement (exp if (exp (exp (name size) ( (exp A) )) != (exp (name size) ( (exp B) ))) (block (statement (exp return (exp false)))) end)) (statement (exp if (exp (exp (name isa) ( (exp A) , (exp Range) )) != (exp (name isa) ( (exp B) , (exp Range) ))) (block (statement (exp return (exp false)))) end)) (statement (exp for (exp i) in (exp (name eachindex) ( (exp A) , (exp B) )) (block (statement (exp if (exp ! (exp ( (exp (exp (exp (exp A) [ (exp i) ]) == (exp B)) [ (exp i) ]) ))) (block (statement (exp return (exp false)))) end))) end)) (statement (exp return (exp true)))) end)) (statement (functionDeclaration (name sub2ind) (parameters ( (parameter dims :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Integer)) })))) }))) )) = (exp 1))) (statement (functionDeclaration (name sub2ind) (parameters ( (parameter dims :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Integer)) })))) }))) , (parameter (parameter I :: (typeExpression Integer)) ...) )) = (exp (name _sub2ind) ( (exp dims) , (exp I) )))) (statement (exp @ (name generated))) (statement (functionDeclaration function (name _sub2ind) (typeParameters { (typeParameter (exp (exp N) , (exp M))) }) (parameters ( (parameter dims :: (typeExpression NTuple (typeParameters { (typeParameter (exp (exp N) , (exp Integer))) }))) , (parameter I :: (typeExpression NTuple (typeParameters { (typeParameter (exp (exp M) , (exp Integer))) }))) )) (block (statement (exp (exp meta) = (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )))) (statement (exp (exp ex) = (exp : (exp ( (exp (exp (exp I) [ (exp $ (exp M)) ]) - (exp 1)) ))))) (statement (exp for (exp i) = (exp (exp (exp (exp M) - (exp 1)) : (exp - (exp 1))) : (exp 1)) (block (statement (exp if (exp (exp i) > (exp N)) (block (statement (exp (exp ex) = (exp : (exp ( (exp (exp (exp I) [ (exp $ (exp i)) ]) - (exp (exp 1) + (exp $ (exp ex)))) )))))) else (block (statement (exp (exp ex) = (exp : (exp ( (exp (exp (exp I) [ (exp $ (exp i)) ]) - (exp (exp 1) + (exp (exp (exp dims) [ (exp $ (exp i)) ]) * (exp $ (exp ex))))) )))))) end))) end)) (statement (exp (name Expr) ( (exp (exp : (exp block)) , (exp meta)) , (exp : (exp ( (exp (exp $ (exp ex)) + (exp 1)) ))) )))) end)) (statement (exp @ (name generated))) (statement (functionDeclaration function (name ind2sub) (typeParameters { (typeParameter (exp N)) }) (parameters ( (parameter dims :: (typeExpression NTuple (typeParameters { (typeParameter (exp (exp N) , (exp Integer))) }))) , (parameter ind :: (typeExpression Integer)) )) (block (statement (exp (exp meta) = (exp (name Expr) ( (exp : (exp meta)) , (exp : (exp inline)) )))) (statement (exp (exp (exp N) == (exp 0)) && (exp return (exp : (exp ( (exp (exp $ (exp meta)) ; (exp (exp (exp ind) == (exp 1)) ? (exp ( )) : (exp (name throw) ( (exp (name BoundsError) ( )) )))) )))))) (statement (exp (exp (exp exprs) = (exp Expr)) [ (exp : (exp ( (exp (exp ind) = (exp (exp ind) - (exp 1))) ))) ])) (statement (exp for (exp i) = (exp (exp 1) : (exp (exp N) - (exp 1))) (block (statement (exp (name push!) ( (exp exprs) , (exp : (exp ( (exp (exp ind2) = (exp (name div) ( (exp ind) , (exp (exp dims) [ (exp $ (exp i)) ]) ))) ))) ))) (statement exp) (statement (exp push!)) (statement (exp ()) (statement (exp (exp exprs) , exp)) (statement (exp Expr)) (statement (exp ()) (statement (exp : exp)) (statement (exp ( = ) ,)) (statement (exp (exp (name symbol) ( (exp : (exp s)) , (exp i) )) , (exp : (exp ( (exp (exp (exp (exp ind) - (exp dims)) [ (exp $ (exp i)) ]) * (exp (exp ind2) + (exp 1))) ) ) ))))) (statement (exp (name push!) ( (exp exprs) , (exp : (exp ( (exp (exp ind) = (exp ind2)) ))) )))) end)) (statement exp) (statement (exp push!)) (statement (exp ()) (statement (exp (exp exprs) , exp)) (statement (exp Expr)) (statement (exp ()) (statement (exp : exp)) (statement (exp ( = ) ,)) (statement (exp (exp (name symbol) ( (exp : (exp s)) , (exp N) )) , (exp : (exp ( (exp (exp ind) + (exp 1)) ) ) ))))) (statement (exp (name Expr) ( (exp (exp (exp : (exp block)) , (exp meta)) , (exp (exp exprs) ...)) , (exp (name Expr) ( (exp : (exp tuple)) , (exp (exp [ (exp (name symbol) ( (exp : (exp s)) , (exp i) )) for (exp i) = (exp (exp 1) : (exp N)) ]) ...) )) )))) end)) (statement (functionDeclaration (name ind2sub) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter ind :: (typeExpression Integer)) )) = (exp (name ind2sub) ( (exp (name size) ( (exp a) )) , (exp ind) )))) (statement (functionDeclaration function (name sub2ind) (typeParameters { (typeParameter T <: (typeExpression Integer)) }) (parameters ( (parameter dims :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp Integer)) })))) }))) , (parameter (parameter I :: (typeExpression AbstractVector (typeParameters { (typeParameter (exp T)) }))) ...) )) (block (statement (exp (exp N) = (exp (name length) ( (exp dims) )))) (statement (exp (exp M) = (exp (name length) ( (exp (exp I) [ (exp 1) ]) )))) (statement (exp (exp indices) = (exp (name Array) (typeParameters { (typeParameter (exp T)) }) ( (exp (name length) ( (exp (exp I) [ (exp 1) ]) )) )))) (statement (exp (name copy!) ( (exp indices) , (exp (exp I) [ (exp 1) ]) ))) (statement (exp (exp (exp s) = (exp dims)) [ (exp 1) ])) (statement (exp for (exp j) = (exp (exp 2) : (exp (name length) ( (exp I) ))) (block (statement (exp (exp (exp Ij) = (exp I)) [ (exp j) ])) (statement (exp for (exp i) = (exp (exp 1) : (exp M)) (block (statement (exp (exp (exp indices) [ (exp i) ]) += (exp (exp s) * (exp ( (exp (exp (exp Ij) [ (exp i) ]) - (exp 1)) )))))) end)) (statement (exp (exp s) *= (exp ( (exp (exp (exp j) <= (exp N)) ? (exp (exp dims) [ (exp j) ]) : (exp 1)) ))))) end)) (statement (exp return (exp indices)))) end)) (statement (functionDeclaration function (name ind2sub) (typeParameters { (typeParameter (exp (exp N) , (exp (exp T) <: (exp Integer)))) }) (parameters ( (parameter dims :: (typeExpression NTuple (typeParameters { (typeParameter (exp (exp N) , (exp Integer))) }))) , (parameter ind :: (typeExpression AbstractVector (typeParameters { (typeParameter (exp T)) }))) )) (block (statement (exp (exp M) = (exp (name length) ( (exp ind) )))) (statement (exp (exp t) = (exp (name NTuple) (typeParameters { (typeParameter (exp (exp N) , (exp (typeExpression Vector (typeParameters { (typeParameter (exp T)) }))))) }) ( (exp (name ntuple) ( (exp (exp n) -> (exp (name Array) (typeParameters { (typeParameter (exp T)) }) ( (exp M) ))) , (exp N) )) )))) (statement (exp (name copy!) ( (exp (exp t) [ (exp 1) ]) , (exp ind) ))) (statement (exp for (exp j) = (exp (exp 1) : (exp (exp N) - (exp 1))) (block (statement (exp (exp (exp d) = (exp dims)) [ (exp j) ])) (statement (exp (exp (exp tj) = (exp t)) [ (exp j) ])) (statement (exp (exp (exp tj2) = (exp t)) [ (exp (exp j) + (exp 1)) ])) (statement (exp for (exp i) = (exp (exp 1) : (exp M)) (block (statement (exp (exp ind2) = (exp (name div) ( (exp (exp (exp tj) [ (exp i) ]) - (exp 1)) , (exp d) )))) (statement (exp (exp (exp tj) [ (exp i) ]) -= (exp (exp d) * (exp ind2)))) (statement (exp (exp (exp tj2) [ (exp i) ]) = (exp (exp ind2) + (exp 1))))) end))) end)) (statement (exp return (exp t)))) end)) (statement (functionDeclaration function (name ind2sub!) (typeParameters { (typeParameter T <: (typeExpression Integer)) }) (parameters ( (parameter sub :: (typeExpression Array (typeParameters { (typeParameter (exp T)) }))) , (parameter dims :: (typeExpression Tuple (typeParameters { (typeParameter (exp (typeExpression Vararg (typeParameters { (typeParameter (exp T)) })))) }))) , (parameter ind :: (typeExpression T)) )) (block (statement (exp (exp ndims) = (exp (name length) ( (exp dims) )))) (statement (exp for (exp i) = (exp (exp 1) : (exp (exp ndims) - (exp 1))) (block (statement (exp (exp ind2) = (exp (exp (name div) ( (exp (exp ind) - (exp 1)) , (exp (exp dims) [ (exp i) ]) )) + (exp 1)))) (statement (exp (exp (exp (exp (exp sub) [ (exp i) ]) = (exp (exp ind) - (exp dims))) [ (exp i) ]) * (exp ( (exp (exp ind2) - (exp 1)) )))) (statement (exp (exp ind) = (exp ind2)))) end)) (statement (exp (exp (exp sub) [ (exp ndims) ]) = (exp ind))) (statement (exp return (exp sub)))) end)) (statement (functionDeclaration function (name map) (parameters ( (parameter f) , (parameter (parameter iters) ...) )) (block (statement (exp (exp result) = (exp [ ]))) (statement (exp (exp len) = (exp (name length) ( (exp iters) )))) (statement (exp (exp states) = (exp [ (exp (name start) ( (exp (exp iters) [ (exp idx) ]) )) for (exp idx) in (exp (exp 1) : (exp len)) ]))) (statement (exp (exp nxtvals) = (exp (name cell) ( (exp len) )))) (statement (exp (exp cont) = (exp true))) (statement (exp for (exp idx) in (exp (exp 1) : (exp len)) (block (statement (exp if (exp (name done) ( (exp (exp iters) [ (exp idx) ]) , (exp (exp states) [ (exp idx) ]) )) (block (statement (exp (exp cont) = (exp false))) (statement (exp break))) end))) end)) (statement (exp while (exp cont) (block (statement (exp for (exp idx) in (exp (exp 1) : (exp len)) (block (statement (exp (exp (exp nxtvals) [ (exp idx) ]) , (exp (exp (exp states) [ (exp idx) ]) = (exp (name next) ( (exp (exp iters) [ (exp idx) ]) , (exp (exp states) [ (exp idx) ]) )))))) end)) (statement (exp (name push!) ( (exp result) , (exp (name f) ( (exp (exp nxtvals) ...) )) ))) (statement (exp for (exp idx) in (exp (exp 1) : (exp len)) (block (statement (exp if (exp (name done) ( (exp (exp iters) [ (exp idx) ]) , (exp (exp states) [ (exp idx) ]) )) (block (statement (exp (exp cont) = (exp false))) (statement (exp break))) end))) end))) end)) (statement (exp result))) end)) (statement (functionDeclaration (name mapslices) (parameters ( (parameter f) , (parameter A :: (typeExpression AbstractArray)) , (parameter dims) )) = (exp (name mapslices) ( (exp (exp f) , (exp A)) , (exp [ (exp (exp dims) ...) ]) )))) (statement (functionDeclaration function (name mapslices) (parameters ( (parameter f) , (parameter A :: (typeExpression AbstractArray)) , (parameter dims :: (typeExpression AbstractVector)) )) (block (statement (exp if (exp (name isempty) ( (exp dims) )) (block (statement (exp return (exp (name map) ( (exp f) , (exp A) ))))) end)) (statement (exp (exp dimsA) = (exp [ (exp (exp (name size) ( (exp A) )) ...) ]))) (statement (exp (exp ndimsA) = (exp (name ndims) ( (exp A) )))) (statement (exp alldims)) = (statement exp) (statement (exp [)) (statement (exp 1)) (statement exp) (statement (exp :)) (statement (exp ndimsA)) ; ] (statement (exp (exp otherdims) = (exp (name setdiff) ( (exp alldims) , (exp dims) )))) (statement (exp (exp idx) = (exp (name cell) ( (exp ndimsA) )))) (statement (exp (name fill!) ( (exp idx) , (exp 1) ))) (statement (exp (exp Asliceshape) = (exp (name tuple) ( (exp (exp (exp dimsA) [ (exp dims) ]) ...) )))) (statement (exp (exp itershape) = (exp (name tuple) ( (exp (exp (exp dimsA) [ (exp otherdims) ]) ...) )))) (statement (exp for (exp d) in (exp dims) (block (statement (exp (exp (exp idx) [ (exp d) ]) = (exp (exp 1) : (exp (name size) ( (exp A) , (exp d) )))))) end)) (statement (exp (exp r1) = (exp (name f) ( (exp (name reshape) ( (exp (exp A) [ (exp (exp idx) ...) ]) , (exp Asliceshape) )) )))) (statement (exp (exp Rsize) = (exp (name copy) ( (exp dimsA) )))) (statement (exp if (exp (exp ! (exp (name isa) ( (exp r1) , (exp AbstractArray) ))) || (exp (exp (name ndims) ( (exp r1) )) == (exp 0))) (block (statement (exp (exp r1) = (exp [ (exp r1) ])))) end)) (statement (exp (exp (exp Rsize) [ (exp dims) ]) = (exp [ (exp (exp (exp (name size) ( (exp r1) )) ...) ; (exp (name ones) ( (exp Int) , (exp (name max) ( (exp 0) , (exp (exp (name length) ( (exp dims) )) - (exp (name ndims) ( (exp r1) ))) )) ))) ]))) (statement (exp (exp R) = (exp (name similar) ( (exp r1) , (exp (name tuple) ( (exp (exp Rsize) ...) )) )))) (statement (exp (exp ridx) = (exp (name cell) ( (exp (name ndims) ( (exp R) )) )))) (statement (exp (name fill!) ( (exp ridx) , (exp 1) ))) (statement (exp for (exp d) in (exp dims) (block (statement (exp (exp (exp ridx) [ (exp d) ]) = (exp (exp 1) : (exp (name size) ( (exp R) , (exp d) )))))) end)) (statement (exp (exp (exp R) [ (exp (exp ridx) ...) ]) = (exp r1))) (statement (exp (exp first) = (exp true))) (statement (exp (exp nidx) = (exp (name length) ( (exp otherdims) )))) (statement (exp for (exp I) in (exp (name CartesianRange) ( (exp itershape) )) (block (statement (exp if (exp first) (block (statement (exp (exp first) = (exp false)))) else (block (statement (exp for (exp i) in (exp (exp 1) : (exp nidx)) (block (statement (exp (exp (exp (exp (exp (exp idx) [ (exp (exp otherdims) [ (exp i) ]) ]) = (exp ridx)) [ (exp (exp otherdims) [ (exp i) ]) ]) = (exp (exp I) . (exp I))) [ (exp i) ]))) end)) (statement (exp (exp (exp R) [ (exp (exp ridx) ...) ]) = (exp (name f) ( (exp (name reshape) ( (exp (exp A) [ (exp (exp idx) ...) ]) , (exp Asliceshape) )) ))))) end))) end)) (statement (exp return (exp R)))) end)) (statement (functionDeclaration function (name promote_to!) (typeParameters { (typeParameter (exp (exp T) , (exp F))) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter offs) , (parameter dest :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter A :: (typeExpression AbstractArray)) )) (block (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp offs) : (exp (name length) ( (exp A) ))) (block (statement (exp (exp el) = (exp (name f) ( (exp (exp A) [ (exp i) ]) )))) (statement (exp (exp S) = (exp (name typeof) ( (exp el) )))) (statement (exp if (exp (exp (exp S) === (exp T)) || (exp (exp S) <: (exp T))) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (exp el) :: (typeExpression T))))) else (block (statement (exp (exp R) = (exp (name promote_type) ( (exp T) , (exp S) )))) (statement (exp if (exp (exp R) !== (exp T)) (block (statement (exp (exp new) = (exp (name similar) ( (exp dest) , (exp R) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp new) , (exp 1)) , (exp dest)) , (exp 1)) , (exp (exp i) - (exp 1)) ))) (statement (exp (exp (exp new) [ (exp i) ]) = (exp el))) (statement (exp return (exp (name promote_to!) ( (exp (exp f) , (exp (exp i) + (exp (exp 1) , (exp new)))) , (exp A) ))))) end)) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp el)))) end))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name map_promote) (parameters ( (parameter f) , (parameter A :: (typeExpression AbstractArray)) )) (block (statement (exp if exp (block (statement (exp (exp (name isempty) ( (exp A) )) ; exp)) (statement (exp return)) (statement (exp (name similar) ( (exp A) , (exp Bottom) ))) ;) end)) (statement (exp (exp first) = (exp (name f) ( (exp (exp A) [ (exp 1) ]) )))) (statement (exp (exp dest) = (exp (name similar) ( (exp A) , (exp (name typeof) ( (exp first) )) )))) (statement (exp (exp (exp dest) [ (exp 1) ]) = (exp first))) (statement (exp return (exp (name promote_to!) ( (exp (exp (exp f) , (exp 2)) , (exp dest)) , (exp A) ))))) end)) (statement (functionDeclaration (name map!) (typeParameters { (typeParameter (exp F)) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter A :: (typeExpression AbstractArray)) )) = (exp (name map!) ( (exp (exp f) , (exp A)) , (exp A) )))) (statement (functionDeclaration function (name map!) (typeParameters { (typeParameter (exp F)) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter A :: (typeExpression AbstractArray)) )) (block (statement (exp for (exp i) = (exp (exp 1) : (exp (name length) ( (exp A) ))) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (name f) ( (exp (exp A) [ (exp i) ]) ))))) end)) (statement (exp return (exp dest)))) end)) (statement (functionDeclaration function (name map_to!) (typeParameters { (typeParameter (exp (exp T) , (exp F))) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter offs) , (parameter dest :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter A :: (typeExpression AbstractArray)) )) (block (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp offs) : (exp (name length) ( (exp A) ))) (block (statement (exp (exp el) = (exp (name f) ( (exp (exp A) [ (exp i) ]) )))) (statement (exp (exp S) = (exp (name typeof) ( (exp el) )))) (statement (exp if (exp (exp (exp S) === (exp T)) || (exp (exp S) <: (exp T))) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (exp el) :: (typeExpression T))))) else (block (statement (exp (exp R) = (exp (name typejoin) ( (exp T) , (exp S) )))) (statement (exp (exp new) = (exp (name similar) ( (exp dest) , (exp R) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp new) , (exp 1)) , (exp dest)) , (exp 1)) , (exp (exp i) - (exp 1)) ))) (statement (exp (exp (exp new) [ (exp i) ]) = (exp el))) (statement (exp return (exp (name map_to!) ( (exp (exp f) , (exp (exp i) + (exp (exp 1) , (exp new)))) , (exp A) ))))) end))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name map) (parameters ( (parameter f) , (parameter A :: (typeExpression AbstractArray)) )) (block (statement (exp if (exp (name isempty) ( (exp A) )) (block (statement (exp return (exp (exp (name isa) ( (exp f) , (exp Type) )) ? (exp (name similar) ( (exp A) , (exp f) )) : (exp (name similar) ( (exp A) )))))) end)) (statement (exp (exp first) = (exp (name f) ( (exp (exp A) [ (exp 1) ]) )))) (statement (exp (exp dest) = (exp (name similar) ( (exp A) , (exp (name typeof) ( (exp first) )) )))) (statement (exp (exp (exp dest) [ (exp 1) ]) = (exp first))) (statement (exp return (exp (name map_to!) ( (exp (exp (exp f) , (exp 2)) , (exp dest)) , (exp A) ))))) end)) (statement (functionDeclaration function (name map!) (typeParameters { (typeParameter (exp F)) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp for (exp i) = (exp (exp 1) : (exp (name length) ( (exp A) ))) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (name f) ( (exp (exp A) [ (exp i) ]) , (exp (exp B) [ (exp i) ]) ))))) end)) (statement (exp return (exp dest)))) end)) (statement (functionDeclaration function (name map_to!) (typeParameters { (typeParameter (exp (exp T) , (exp F))) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter offs) , (parameter dest :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp offs) : (exp (name length) ( (exp A) ))) (block (statement (exp (exp el) = (exp (name f) ( (exp (exp A) [ (exp i) ]) , (exp (exp B) [ (exp i) ]) )))) (statement (exp (exp S) = (exp (name typeof) ( (exp el) )))) (statement (exp if (exp (exp ( (exp (exp S) !== (exp T)) )) && (exp ! (exp ( (exp (exp S) <: (exp T)) )))) (block (statement (exp (exp R) = (exp (name typejoin) ( (exp T) , (exp S) )))) (statement (exp (exp new) = (exp (name similar) ( (exp dest) , (exp R) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp new) , (exp 1)) , (exp dest)) , (exp 1)) , (exp (exp i) - (exp 1)) ))) (statement (exp (exp (exp new) [ (exp i) ]) = (exp el))) (statement (exp return (exp (name map_to!) ( (exp (exp f) , (exp (exp i) + (exp (exp (exp 1) , (exp new)) , (exp A)))) , (exp B) ))))) end)) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (exp el) :: (typeExpression T))))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name map) (parameters ( (parameter f) , (parameter A :: (typeExpression AbstractArray)) , (parameter B :: (typeExpression AbstractArray)) )) (block (statement (exp (exp shp) = (exp (name promote_shape) ( (exp (name size) ( (exp A) )) , (exp (name size) ( (exp B) )) )))) (statement (exp if (exp (exp (name prod) ( (exp shp) )) == (exp 0)) (block (statement (exp return (exp (name similar) ( (exp (exp A) , (exp (name promote_type) ( (exp (name eltype) ( (exp A) )) , (exp (name eltype) ( (exp B) )) ))) , (exp shp) ))))) end)) (statement (exp (exp first) = (exp (name f) ( (exp (exp A) [ (exp 1) ]) , (exp (exp B) [ (exp 1) ]) )))) (statement (exp (exp dest) = (exp (name similar) ( (exp (exp A) , (exp (name typeof) ( (exp first) ))) , (exp shp) )))) (statement (exp (exp (exp dest) [ (exp 1) ]) = (exp first))) (statement (exp return (exp (name map_to!) ( (exp (exp (exp (exp f) , (exp 2)) , (exp dest)) , (exp A)) , (exp B) ))))) end)) (statement (functionDeclaration (name ith_all) (parameters ( (parameter i) , (parameter :: (typeExpression Tuple (typeParameters { }))) )) = (exp ( )))) (statement (functionDeclaration (name ith_all) (parameters ( (parameter i) , (parameter as) )) = (exp ( (exp (exp as) [ (exp 1) ] [ (exp i) ]) , (exp (exp (name ith_all) ( (exp i) , (exp (name tail) ( (exp as) )) )) ...) )))) (statement (functionDeclaration function (name map_n!) (typeParameters { (typeParameter (exp F)) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter As) )) (block (statement (exp (exp n) = (exp (name length) ( (exp (exp As) [ (exp 1) ]) )))) (statement (exp for (exp i) = (exp (exp 1) : (exp n)) (block (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (name f) ( (exp (exp (name ith_all) ( (exp i) , (exp As) )) ...) ))))) end)) (statement (exp return (exp dest)))) end)) (statement (functionDeclaration (name map!) (typeParameters { (typeParameter (exp F)) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter dest :: (typeExpression AbstractArray)) , (parameter (parameter As :: (typeExpression AbstractArray)) ...) )) = (exp (name map_n!) ( (exp (exp f) , (exp dest)) , (exp As) )))) (statement (functionDeclaration function (name map_to_n!) (typeParameters { (typeParameter (exp (exp T) , (exp F))) }) (parameters ( (parameter f :: (typeExpression F)) , (parameter offs) , (parameter dest :: (typeExpression AbstractArray (typeParameters { (typeParameter (exp T)) }))) , (parameter As) )) (block (statement (exp @ (name inbounds) (exp for (exp i) = (exp (exp offs) : (exp (name length) ( (exp (exp As) [ (exp 1) ]) ))) (block (statement (exp (exp el) = (exp (name f) ( (exp (exp (name ith_all) ( (exp i) , (exp As) )) ...) )))) (statement (exp (exp S) = (exp (name typeof) ( (exp el) )))) (statement (exp if (exp (exp ( (exp (exp S) !== (exp T)) )) && (exp ! (exp ( (exp (exp S) <: (exp T)) )))) (block (statement (exp (exp R) = (exp (name typejoin) ( (exp T) , (exp S) )))) (statement (exp (exp new) = (exp (name similar) ( (exp dest) , (exp R) )))) (statement (exp (name copy!) ( (exp (exp (exp (exp new) , (exp 1)) , (exp dest)) , (exp 1)) , (exp (exp i) - (exp 1)) ))) (statement (exp (exp (exp new) [ (exp i) ]) = (exp el))) (statement (exp return (exp (name map_to_n!) ( (exp (exp f) , (exp (exp i) + (exp (exp 1) , (exp new)))) , (exp As) ))))) end)) (statement (exp (exp (exp dest) [ (exp i) ]) = (exp (exp el) :: (typeExpression T))))) end) (exp return (exp dest))))) end)) (statement (functionDeclaration function (name map) (parameters ( (parameter f) , (parameter (parameter As :: (typeExpression AbstractArray)) ...) )) (block (statement (exp (exp shape) = (exp (name mapreduce) ( (exp (exp size) , (exp promote_shape)) , (exp As) )))) (statement (exp if (exp (exp (name prod) ( (exp shape) )) == (exp 0)) (block (statement (exp return (exp (name similar) ( (exp (exp (exp As) [ (exp 1) ]) , (exp (name promote_eltype) ( (exp (exp As) ...) ))) , (exp shape) ))))) end)) (statement (exp (exp first) = (exp (name f) ( (exp (exp (name map) ( (exp (exp (exp a) -> (exp a)) [ (exp 1) ]) , (exp As) )) ...) )))) (statement (exp (exp dest) = (exp (name similar) ( (exp (exp (exp As) [ (exp 1) ]) , (exp (name typeof) ( (exp first) ))) , (exp shape) )))) (statement (exp (exp (exp dest) [ (exp 1) ]) = (exp first))) (statement (exp return (exp (name map_to_n!) ( (exp (exp (exp f) , (exp 2)) , (exp dest)) , (exp As) ))))) end)) (statement (functionDeclaration (name push!) (parameters ( (parameter A) , (parameter a) , (parameter b) )) = (exp (name push!) ( (exp (name push!) ( (exp A) , (exp a) )) , (exp b) )))) (statement (functionDeclaration (name push!) (parameters ( (parameter A) , (parameter a) , (parameter b) , (parameter (parameter c) ...) )) = (exp (name push!) ( (exp (name push!) ( (exp (exp A) , (exp a)) , (exp b) )) , (exp (exp c) ...) )))) (statement (functionDeclaration (name unshift!) (parameters ( (parameter A) , (parameter a) , (parameter b) )) = (exp (name unshift!) ( (exp (name unshift!) ( (exp A) , (exp b) )) , (exp a) )))) (statement (functionDeclaration (name unshift!) (parameters ( (parameter A) , (parameter a) , (parameter b) , (parameter (parameter c) ...) )) = (exp (name unshift!) ( (exp (exp (name unshift!) ( (exp A) , (exp (exp c) ...) )) , (exp a)) , (exp b) )))) (statement (exp const hashaa_seed = (exp (exp UInt) === (exp UInt64)))) ? (statement (exp 0x7)) (statement (exp (exp f53e68ceb575e76) : (exp 0))) (statement (exp xeb575e76)) (statement (exp const hashrle_seed = (exp (exp UInt) == (exp UInt64)))) ? (statement (exp 0x2)) (statement (exp (exp aab8909bfea414c) : (exp 0))) (statement (exp xbfea414c)) (statement (functionDeclaration function (name hash) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter h :: (typeExpression UInt)) )) (block (statement (exp (exp h) += (exp hashaa_seed))) (statement (exp (exp h) += (exp (name hash) ( (exp (name size) ( (exp a) )) )))) (statement (exp (exp state) = (exp (name start) ( (exp a) )))) (statement (exp (exp (name done) ( (exp a) , (exp state) )) && (exp return (exp h)))) (statement (exp (exp x2) , (exp (exp state) = (exp (name next) ( (exp a) , (exp state) ))))) (statement (exp (exp (name done) ( (exp a) , (exp state) )) && (exp return (exp (name hash) ( (exp x2) , (exp h) ))))) (statement (exp (exp x1) = (exp x2))) (statement (exp while (exp ! (exp (name done) ( (exp a) , (exp state) ))) (block (statement (exp (exp x1) = (exp x2))) (statement (exp (exp x2) , (exp (exp state) = (exp (name next) ( (exp a) , (exp state) ))))) (statement (exp if (exp (name isequal) ( (exp x2) , (exp x1) )) (block (statement (exp (exp runlength) = (exp 2))) (statement (exp while (exp ! (exp (name done) ( (exp a) , (exp state) ))) (block (statement (exp (exp x2) , (exp (exp state) = (exp (name next) ( (exp a) , (exp state) ))))) (statement (exp (exp (name isequal) ( (exp x1) , (exp x2) )) || (exp break))) (statement (exp (exp runlength) += (exp 1)))) end)) (statement (exp (exp h) += (exp hashrle_seed))) (statement (exp (exp h) = (exp (name hash) ( (exp runlength) , (exp h) ))))) end)) (statement (exp (exp h) = (exp (name hash) ( (exp x1) , (exp h) ))))) end)) (statement (exp (exp ! (exp (name isequal) ( (exp x2) , (exp x1) ))) && (exp ( (exp (exp h) = (exp (name hash) ( (exp x2) , (exp h) ))) )))) (statement (exp return (exp h)))) end))))